<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISS Speed Analysis Dashboard v2</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        .section {
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
        }
        .section:last-child {
            border-bottom: none;
        }
        .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #007bff;
        }
        
        .section-link {
            margin-bottom: 15px;
            text-align: center;
        }
        
        .section-link a {
            display: inline-block;
            padding: 8px 16px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.2);
        }
        
        .section-link a:hover {
            background: linear-gradient(135deg, #0056b3, #004085);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
        }
        
        .section-description {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 20px;
            line-height: 1.5;
            font-style: italic;
        }
        .control-row {
            display: flex;
            align-items: center;
            margin: 15px 0;
            gap: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            font-weight: bold;
            color: #495057;
            min-width: 120px;
            text-align: right;
        }
        .control-group input[type="range"] {
            width: 150px;
            margin: 0 10px;
        }
        .control-group input[type="number"] {
            width: 80px;
            padding: 5px 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .control-group select {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            min-width: 200px;
        }
        .value-display {
            font-weight: bold;
            color: #007bff;
            min-width: 50px;
            text-align: center;
        }
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 5px;
        }
        .btn:hover {
            background: #0056b3;
        }
        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .btn-primary {
            background: #007bff;
        }
        .btn-success {
            background: #28a745;
        }
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #dee2e6;
        }
        
        .stat-card.gps-stat {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-left: 4px solid #2196f3;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            font-size: 14px;
            color: #6c757d;
            margin-top: 5px;
        }
        .stat-description {
            font-size: 10px;
            color: #adb5bd;
            margin-top: 3px;
            font-style: italic;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #6c757d;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .success {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .plot-container {
            margin: 20px 0;
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .legend-item {
            display: inline-block;
            margin-right: 15px;
            margin-bottom: 5px;
        }
        
        .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .legend-text {
            font-size: 14px;
            vertical-align: middle;
        }
        
        .range-slider-group {
            width: 100%;
        }
        
        .range-container {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 12px;
            margin: 5px 0;
        }
        
        .range-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .range-value {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            border: 2px solid #007bff;
            border-radius: 6px;
            padding: 6px 10px;
            min-width: 60px;
            box-shadow: 0 1px 3px rgba(0,123,255,0.1);
        }
        
        .start-value {
            border-color: #28a745;
        }
        
        .end-value {
            border-color: #dc3545;
        }
        
        .value-label {
            font-size: 10px;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
        }
        
        .value-number {
            font-size: 18px;
            font-weight: 700;
            color: #212529;
        }
        
        .start-value .value-number {
            color: #28a745;
        }
        
        .end-value .value-number {
            color: #dc3545;
        }
        
        .range-separator {
            font-size: 14px;
            font-weight: 600;
            color: #6c757d;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .dual-range-container {
            position: relative;
            height: 30px;
            margin: 10px 0;
        }
        
        .range-track {
            position: absolute;
            top: 12px;
            left: 0;
            right: 0;
            height: 6px;
            background: #dee2e6;
            border-radius: 3px;
            z-index: 1;
        }
        
        .range-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 30px;
            background: transparent;
            outline: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            pointer-events: none;
            z-index: 2;
        }
        
        .range-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: all;
            position: relative;
            z-index: 3;
        }
        
        .start-range::-webkit-slider-thumb {
            background: #28a745;
        }
        
        .end-range::-webkit-slider-thumb {
            background: #dc3545;
        }
        
        .range-input::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: all;
            position: relative;
            z-index: 3;
        }
        
        .start-range::-moz-range-thumb {
            background: #28a745;
        }
        
        .end-range::-moz-range-thumb {
            background: #dc3545;
        }
        
        .range-input::-webkit-slider-track {
            height: 6px;
            background: transparent;
            border-radius: 3px;
        }
        
        .range-input::-moz-range-track {
            height: 6px;
            background: transparent;
            border-radius: 3px;
            border: none;
        }
        
        .range-info {
            text-align: center;
            font-size: 12px;
            color: #6c757d;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 4px 8px;
            margin-top: 8px;
        }
        
        /* Help tooltip styles */
        .help-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: #007bff;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            margin-left: 5px;
            vertical-align: middle;
            transition: background-color 0.2s;
        }
        
        .help-icon:hover {
            background: #0056b3;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltip-content {
            visibility: hidden;
            width: 300px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 12px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 13px;
            line-height: 1.4;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .tooltip .tooltip-content::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        
        .tooltip.show .tooltip-content {
            visibility: visible;
            opacity: 1;
        }
        
        .tooltip-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .tooltip-text {
            margin-bottom: 8px;
        }
        
        .tooltip-example {
            font-style: italic;
            color: #ccc;
            font-size: 12px;
        }
        
        .range-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .range-input:disabled::-webkit-slider-thumb {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .range-input:disabled::-moz-range-thumb {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .range-container.disabled {
            opacity: 0.6;
            background: #f1f3f4;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .slider-container input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }
        
        .slider-container input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
        }
        
        .slider-container span {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #007bff;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .checkbox-group input[type="checkbox"] {
            margin: 0;
        }
        .progress-container {
            margin: 20px 0;
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        .progress-text {
            text-align: center;
            font-size: 14px;
            color: #495057;
            margin-top: 5px;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }
        
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: black;
        }
        
        .image-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .image-item {
            flex: 1;
            text-align: center;
        }
        
        .image-item img {
            max-width: 100%;
            height: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        
        .image-item h4 {
            margin: 10px 0 5px 0;
            color: #333;
        }
        
        .pair-info {
            margin: 20px 0;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        
        .info-label {
            font-weight: bold;
            color: #495057;
        }
        
        .info-value {
            color: #212529;
        }
        
        .matches-section {
            margin: 20px 0;
        }
        
        .matches-section h3 {
            color: #333;
            margin-bottom: 10px;
        }
        
        /* GitHub Comparison Styles */
        .github-comparison-results {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-top: 10px;
        }
        
        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }
        
        .comparison-header h4 {
            margin: 0;
            color: #495057;
        }
        
        .comparison-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        
        .stat-label {
            font-weight: 500;
            color: #6c757d;
        }
        
        .stat-value {
            font-weight: 600;
            color: #495057;
        }
        
        .comparison-summary {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        
        .comparison-summary h5 {
            margin: 0 0 10px 0;
            color: #495057;
        }
        
        .comparison-summary p {
            margin: 5px 0;
            color: #6c757d;
            font-size: 14px;
        }
        
        /* Checkbox Group Styles */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
            color: #495057;
        }
        
        .checkbox-label input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.1);
        }
        
        /* Algorithm Comparison Results */
        .algorithm-comparison-results {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-top: 10px;
        }
        
        .algorithm-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .algorithm-card:last-child {
            margin-bottom: 0;
        }
        
        .algorithm-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .algorithm-name {
            font-weight: 600;
            color: #495057;
            font-size: 16px;
        }
        
        .algorithm-description {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        
        .algorithm-stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        
        .algorithm-stat {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .algorithm-stat-label {
            font-size: 11px;
            color: #6c757d;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .algorithm-stat-value {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            margin-top: 2px;
        }
        
        .comparison-summary {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .comparison-summary h5 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        
        .winner-badge {
            background: #4caf50;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        
        /* Collapsible Section Styles */
        .collapsible {
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
        }
        
        .collapsible:hover {
            background-color: #f8f9fa;
        }
        
        .collapse-icon {
            display: inline-block;
            margin-right: 8px;
            transition: transform 0.3s ease;
            font-size: 12px;
            color: #6c757d;
        }
        
        .collapsible.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }
        
        .section-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .section-content.collapsed {
            max-height: 0;
            padding: 0;
            margin: 0;
            opacity: 0;
        }
        
        /* Filter Categories Styles */
        .filter-categories {
            margin-top: 20px;
        }
        
        .filter-category {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .category-title {
            margin: 0 0 8px 0;
            color: #495057;
            font-size: 18px;
            font-weight: 600;
        }
        
        .category-description {
            margin: 0 0 20px 0;
            color: #6c757d;
            font-size: 14px;
            font-style: italic;
        }
        
        .filter-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }
        
        .filter-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
        }
        
        .filter-header {
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }
        
        .filter-description {
            font-size: 12px;
            color: #6c757d;
            margin: 5px 0 0 0;
            line-height: 1.4;
            font-style: italic;
        }
        
        .filter-params {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .setting-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        
        .setting-group h5 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 14px;
            font-weight: 600;
        }
        
        .setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .setting-item label {
            min-width: 120px;
            font-size: 13px;
            color: #6c757d;
        }
        
        .setting-item input {
            width: 80px;
            padding: 4px 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .value-display {
            font-size: 12px;
            color: #007bff;
            font-weight: 500;
            min-width: 40px;
        }
        
        .gsd-info {
            margin-top: 8px;
            padding: 8px 12px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            font-size: 11px;
            color: #6c757d;
            line-height: 1.4;
        }
        
        .filter-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }
        
        .btn-icon {
            margin-right: 8px;
            font-size: 14px;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            border-color: #6c757d;
            color: white;
        }
        
            .btn-secondary:hover {
                background-color: #5a6268;
                border-color: #545b62;
            }
            
            /* Config Categories Styles (for Section 2) */
            .config-categories {
                margin-top: 20px;
            }
            
            .config-category {
                background: #f8f9fa;
                border: 1px solid #e9ecef;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .config-grid {
                display: grid;
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .config-item {
                background: white;
                border: 1px solid #dee2e6;
                border-radius: 6px;
                padding: 15px;
            }
            
            .config-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 10px;
            }
            
            .config-select {
                width: 100%;
                padding: 8px 12px;
                border: 1px solid #ced4da;
                border-radius: 4px;
                font-size: 14px;
                background-color: white;
            }
            
            .config-description {
                font-size: 12px;
                color: #6c757d;
                margin-top: 8px;
                font-style: italic;
            }
            
            .config-params {
                margin-top: 15px;
                padding-top: 15px;
                border-top: 1px solid #e9ecef;
            }
            
            .param-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 20px;
            }
            
            .param-group {
                background: #f8f9fa;
                padding: 15px;
                border-radius: 6px;
                border: 1px solid #e9ecef;
            }
            
            .param-group label {
                display: block;
                margin-bottom: 8px;
                font-size: 13px;
                color: #495057;
                font-weight: 600;
            }
            
            .param-input-group {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            
            .param-slider {
                flex: 1;
                height: 6px;
                border-radius: 3px;
                background: #ddd;
                outline: none;
                -webkit-appearance: none;
            }
            
            .param-slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 18px;
                height: 18px;
                border-radius: 50%;
                background: #007bff;
                cursor: pointer;
            }
            
            .param-slider::-moz-range-thumb {
                width: 18px;
                height: 18px;
                border-radius: 50%;
                background: #007bff;
                cursor: pointer;
                border: none;
            }
            
            .param-description {
                font-size: 11px;
                color: #6c757d;
                margin-top: 5px;
                font-style: italic;
            }
            
            .config-actions {
                display: flex;
                justify-content: center;
                margin-top: 30px;
                padding-top: 20px;
                border-top: 2px solid #e9ecef;
            }
            
            .btn-large {
                padding: 12px 24px;
                font-size: 16px;
                font-weight: 600;
            }
            
            /* Comparison Categories Styles (for Section 3B) */
            .comparison-categories {
                margin-top: 20px;
            }
            
            .comparison-category {
                background: #f8f9fa;
                border: 1px solid #e9ecef;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .algorithm-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 20px;
            }
            
            .algorithm-item {
                background: white;
                border: 1px solid #dee2e6;
                border-radius: 6px;
                padding: 20px;
                transition: all 0.2s ease;
            }
            
            .algorithm-item:hover {
                border-color: #007bff;
                box-shadow: 0 2px 8px rgba(0, 123, 255, 0.1);
            }
            
            .algorithm-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 15px;
            }
            
            .algorithm-description {
                font-size: 13px;
                color: #6c757d;
                line-height: 1.5;
                background: #f8f9fa;
                padding: 12px;
                border-radius: 4px;
                border-left: 3px solid #007bff;
            }
            
            .comparison-results {
                background: #f8f9fa;
                border: 1px solid #e9ecef;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .comparison-actions {
                display: flex;
                justify-content: center;
                margin-top: 20px;
                padding-top: 20px;
                border-top: 2px solid #e9ecef;
            }
            
            .loading {
                text-align: center;
                padding: 40px 20px;
                color: #6c757d;
            }
            
            .loading-icon {
                font-size: 48px;
                margin-bottom: 15px;
                opacity: 0.7;
            }
            
            .loading-text {
                font-size: 16px;
                font-weight: 600;
                margin-bottom: 8px;
            }
            
            .loading-subtext {
                font-size: 13px;
                opacity: 0.8;
            }
            
            /* Comparison Progress Styles */
            .comparison-progress {
                background: #f8f9fa;
                border: 1px solid #e9ecef;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .comparison-progress .progress-container {
                margin-top: 15px;
            }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ISS Speed Analysis Dashboard v2</h1>
            <p>Advanced Image Processing and Speed Calculation</p>
        </div>


        <!-- Section 1: Photo Folder and Range Selection -->
        <div class="section">
            <div class="section-title">Section 1: Photo Selection</div>
            <div class="control-row">
                <div class="control-group">
                    <label>Photo Folder:</label>
                    <select id="folderSelect">
                        <option value="">Select a folder...</option>
                    </select>
                    <div id="noFoldersMessage" style="display: none; margin-top: 8px; padding: 8px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; font-size: 14px; color: #6c757d;">
                        ℹ️ No photo folders found. Please add photos-* folders to your project directory.
                    </div>
                </div>
                <!-- Railway environment: File upload -->
                <div id="railwayFileUpload" class="control-group" style="display: none;">
                    <label>Upload Photos:</label>
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                        <input type="file" id="fileUpload" multiple accept=".jpg,.jpeg,.png,.tiff,.tif" style="display: none;">
                        <button type="button" id="uploadButton" onclick="document.getElementById('fileUpload').click()" style="padding: 10px 20px; background: linear-gradient(135deg, #28a745, #20c997); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            📤 Choose Photos
                        </button>
                        <input type="text" id="folderNameInput" placeholder="Folder name (optional)" style="width: 180px; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 4px;">
                    </div>
                    <div style="margin-top: 8px; font-size: 13px; color: #6c757d;">
                        💡 Select multiple image files (.jpg, .png, .tiff) to upload and analyze
                    </div>
                </div>
            </div>
            <div id="uploadStatus" style="margin-top: 10px; display: none;"></div>
                <div class="control-group range-slider-group">
                    <label>Image Range:</label>
                    <div class="range-container">
                        <div class="range-display">
                            <div class="range-value start-value">
                                <span class="value-label">Start</span>
                                <span id="startLabel" class="value-number">0</span>
                            </div>
                            <div class="range-separator">to</div>
                            <div class="range-value end-value">
                                <span class="value-label">End</span>
                                <span id="endLabel" class="value-number">9</span>
                            </div>
                        </div>
                        <div class="dual-range-container">
                            <div class="range-track"></div>
                            <input type="range" id="startIdx" min="0" max="100" value="0" class="range-input start-range">
                            <input type="range" id="endIdx" min="0" max="100" value="9" class="range-input end-range">
                        </div>
                        <div class="range-info">
                            <span id="rangeInfo">Processing 10 images (0-9)</span>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <label>Total Images:</label>
                    <span id="totalImages" class="value-display">-</span>
                </div>
            </div>
            <div class="control-row">
                <div class="control-group">
                    <button id="cacheStatusBtn" onclick="showCacheStatus()" class="btn-secondary">📊 Cache Status</button>
                    <button id="clearCacheBtn" onclick="clearAllCache()" class="btn-secondary">🗑️ Clear All Cache</button>
                </div>
            </div>
        </div>

        <!-- Section 2: Algorithm Configuration -->
        <div class="section">
            <div class="section-title">Section 2: Algorithm Configuration
                <div class="tooltip">
                    <span class="help-icon">?</span>
                    <div class="tooltip-content">
                        <div class="tooltip-title">Algorithm Configuration</div>
                        <div class="tooltip-text">Configure the computer vision algorithm and processing parameters for ISS speed calculation.</div>
                        <div class="tooltip-example">Choose between ORB and SIFT algorithms, enable FLANN matching for faster processing, and configure contrast enhancement.</div>
                    </div>
                </div>
            </div>
            <div class="section-link">
                <a href="https://docs.opencv.org/3.4/db/d27/tutorial_py_table_of_contents_feature2d.html" target="_blank" rel="noopener noreferrer">🔍 Discover OpenCV Feature Detection</a>
            </div>
            <!-- Algorithm Categories -->
            <div class="config-categories">
                
                <!-- Core Algorithm Settings -->
                <div class="config-category">
                    <h4 class="category-title">🔧 Core Algorithm Settings</h4>
                    <p class="category-description">Choose the feature detection algorithm and matching method</p>
                    
                    <div class="config-grid">
                        <div class="config-item">
                            <div class="config-header">
                                <label for="algorithmSelect">Feature Detection Algorithm</label>
                                <div class="tooltip">
                                    <span class="help-icon">?</span>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">Feature Detection Algorithm</div>
                                        <div class="tooltip-text"><strong>ORB:</strong> Fast, binary descriptors, good for real-time applications.<br><strong>SIFT:</strong> More accurate, float descriptors, slower but more robust.</div>
                                        <div class="tooltip-example">ORB is recommended for speed, SIFT for accuracy.</div>
                                    </div>
                                </div>
                            </div>
                            <select id="algorithmSelect" class="config-select">
                                <option value="ORB">ORB (Fast & Efficient)</option>
                                <option value="SIFT">SIFT (Accurate & Robust)</option>
                            </select>
                        </div>
                        
                        <div class="config-item">
                            <div class="config-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="useFlann">
                                    <span class="checkmark"></span>
                                    Use FLANN Matching
                                </label>
                                <div class="tooltip">
                                    <span class="help-icon">?</span>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">FLANN Matching</div>
                                        <div class="tooltip-text">Fast Library for Approximate Nearest Neighbors - significantly faster matching for large feature sets.</div>
                                        <div class="tooltip-example">Recommended for SIFT, optional for ORB.</div>
                                    </div>
                                </div>
                            </div>
                            <div class="config-description"><strong>What it does:</strong> Enables Fast Library for Approximate Nearest Neighbors (FLANN) matching<br>
                                <strong>Method:</strong> Uses optimized algorithms for faster feature matching between images<br>
                                <strong>Logic:</strong> Approximates nearest neighbor search instead of exact matching for speed<br>
                                <strong>Example:</strong> Reduces matching time from 10s to 2s for large feature sets (1000+ features)<br>
                                <strong>Purpose:</strong> Significantly improves processing speed for datasets with many keypoints</div>
                        </div>
                        
                        <div class="config-item">
                            <div class="config-header">
                                <label for="maxFeatures">Maximum Features</label>
                                <div class="tooltip">
                                    <span class="help-icon">?</span>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">Maximum Features</div>
                                        <div class="tooltip-text">Maximum number of keypoints to detect per image. More features = better matching but slower processing.</div>
                                        <div class="tooltip-example">Recommended: 500-1000 for ORB, 1000-2000 for SIFT.</div>
                                    </div>
                                </div>
                            </div>
                            <div class="slider-container">
                                <input type="range" id="maxFeatures" min="100" max="5000" value="1000" step="100">
                                <span id="maxFeaturesValue">1000</span>
                            </div>
                            <div class="config-description"><strong>What it does:</strong> Sets the maximum number of keypoints to detect in each image<br>
                                <strong>Method:</strong> Limits the feature detector to find only the strongest N keypoints<br>
                                <strong>Logic:</strong> Higher values = more features but slower processing, lower values = faster but fewer features<br>
                                <strong>Example:</strong> 1000 features = good balance, 500 = faster processing, 2000 = more detail but slower<br>
                                <strong>Purpose:</strong> Balances feature detection quality with processing speed and memory usage</div>
                        </div>
                    </div>
                </div>
                
                <!-- Image Processing Settings -->
                <div class="config-category">
                    <h4 class="category-title">🖼️ Image Processing Settings</h4>
                    <p class="category-description">Configure image preprocessing to improve feature detection</p>
                    
                    <div class="config-grid">
                        <div class="config-item">
                            <div class="config-header">
                                <label for="contrastEnhancement">Contrast Enhancement</label>
                                <div class="tooltip">
                                    <span class="help-icon">?</span>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">Contrast Enhancement</div>
                                        <div class="tooltip-text">Preprocessing technique to improve feature detection by enhancing image contrast.</div>
                                        <div class="tooltip-example">CLAHE is recommended for most images, especially those with poor lighting.</div>
                                    </div>
                                </div>
                            </div>
                            <select id="contrastEnhancement" class="config-select">
                                <option value="clahe">CLAHE (Recommended)</option>
                                <option value="histogram_eq">Histogram Equalization</option>
                                <option value="gamma">Gamma Correction</option>
                                <option value="unsharp">Unsharp Masking</option>
                                <option value="none">None (Original Image)</option>
                            </select>
                            <div class="config-description"><strong>What it does:</strong> Applies image enhancement techniques to improve feature detection quality<br>
                                <strong>Method:</strong> Uses various algorithms (CLAHE, histogram equalization, gamma correction, unsharp masking)<br>
                                <strong>Logic:</strong> Enhances image contrast and sharpness to make keypoints more detectable<br>
                                <strong>Example:</strong> CLAHE improves cloudy images, gamma correction helps with lighting variations<br>
                                <strong>Purpose:</strong> Increases the number and quality of detected keypoints in challenging lighting conditions</div>
                        </div>
                    </div>
                </div>
                
                <!-- Quality Control Settings -->
                <div class="config-category">
                    <h4 class="category-title">🎯 Quality Control Settings</h4>
                    <p class="category-description">Filter out false matches and improve result accuracy</p>
                    
                    <div class="config-grid">
                        <div class="config-item">
                            <div class="config-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="useRansacHomography">
                                    <span class="checkmark"></span>
                                    Use RANSAC/Homography Filtering
                                </label>
                                <div class="tooltip">
                                    <span class="help-icon">?</span>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">RANSAC/Homography Filtering</div>
                                        <div class="tooltip-text">Uses geometric consistency to filter out false matches from clouds and noise. Only keeps matches that follow a consistent perspective transformation. Combines RANSAC outlier detection with homography model fitting.</div>
                                        <div class="tooltip-example">Recommended for images with clouds or poor visibility to improve match quality.</div>
                                    </div>
                                </div>
                            </div>
                            <div class="config-description"><strong>What it does:</strong> Applies RANSAC (Random Sample Consensus) algorithm to filter out false matches<br>
                                <strong>Method:</strong> Uses homography estimation to identify geometrically consistent matches<br>
                                <strong>Logic:</strong> Removes matches that don't fit the expected geometric transformation between images<br>
                                <strong>Example:</strong> Filters out matches from clouds, shadows, or other non-ISS features<br>
                                <strong>Purpose:</strong> Improves accuracy by removing false positive matches that would skew speed calculations</div>
                            
                            <div id="ransacHomographyParams" class="config-params" style="display: none;">
                                <div class="param-grid">
                                    <div class="param-group">
                                        <label for="ransacThreshold">RANSAC Threshold</label>
                                        <div class="param-input-group">
                                            <input type="range" id="ransacThreshold" min="1.0" max="10.0" step="0.5" value="5.0" class="param-slider">
                                            <span class="value-display" id="ransacThresholdValue">5.0</span>
                                        </div>
                                        <div class="param-description">Lower values = stricter filtering</div>
                                    </div>
                                    
                                    <div class="param-group">
                                        <label for="ransacMinMatches">Minimum Matches</label>
                                        <div class="param-input-group">
                                            <input type="range" id="ransacMinMatches" min="4" max="20" value="10" class="param-slider">
                                            <span class="value-display" id="ransacMinMatchesValue">10</span>
                                        </div>
                                        <div class="param-description">Minimum matches required for valid pair</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Action Button -->
            <div class="config-actions">
                <button class="btn btn-primary btn-large" id="loadBtn" onclick="loadData()">
                    <span class="btn-icon">🚀</span>
                    Load Data & Process Images
                </button>
            </div>
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Processing...</div>
            </div>
        </div>

        <!-- Section 3: Statistics -->
        <div class="section">
            <div class="section-title">Section 3: Overall Statistics
                <div class="tooltip">
                    <span class="help-icon">?</span>
                    <div class="tooltip-content">
                        <div class="tooltip-title">Speed Statistics</div>
                        <div class="tooltip-text"><strong>Computer Vision Speed:</strong> Calculated from feature matching between image pairs using pixel distances and GSD.</div>
                        <div class="tooltip-example">These statistics show the performance of the computer vision algorithm for ISS speed calculation.</div>
                    </div>
                </div>
            </div>
            <div id="statisticsContainer">
                <div class="loading">Click "Load Data" to see statistics</div>
            </div>
        </div>


        <!-- Section 4: Data Filters -->
        <div class="section">
            <div class="section-title">Section 4: Data Filters</div>
            <p class="section-description">Apply various filters to refine your analysis and focus on the most reliable data points. Use filters to remove outliers, focus on clear images, or apply machine learning classification.</p>
            
            <!-- Filter Categories -->
            <div class="filter-categories">
                
                <!-- Statistical Filters -->
                <div class="filter-category">
                    <h4 class="category-title">📊 Statistical Filters</h4>
                    <p class="category-description">Remove statistical outliers to improve data quality</p>
                    
                    <div class="filter-grid">
                        <div class="filter-item">
                            <div class="filter-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="enableKeypointPercentile">
                                    <span class="checkmark"></span>
                                    Keypoint Percentile Filter
                                </label>
                                <p class="filter-description">
                                    <strong>What it does:</strong> Filters based on speed percentiles of individual matches with separate top and bottom thresholds<br>
                                    <strong>Method:</strong> Uses np.percentile() to calculate separate speed thresholds for bottom and top percentiles<br>
                                    <strong>Logic:</strong> Removes matches with speeds in the bottom X% and/or top Y% of all speeds (configurable separately)<br>
                                    <strong>Example:</strong> Bottom 5% + Top 10% means it removes the slowest 5% and fastest 10% of all match speeds<br>
                                    <strong>Purpose:</strong> Removes outlier speeds with flexible control over slow vs fast outlier removal
                                </p>
                            </div>
                            <div class="filter-params" id="keypointPercentileParam" style="display: none;">
                                <label>Percentile:</label>
                                <div class="param-group">
                                    <label>Bottom Percentile:</label>
                                    <input type="number" id="keypointPercentileBottom" value="5" min="0" max="50" step="1">
                                    <span class="value-display" id="keypointPercentileBottomValue">5%</span>
                                </div>
                                <div class="param-group">
                                    <label>Top Percentile:</label>
                                    <input type="number" id="keypointPercentileTop" value="5" min="0" max="50" step="1">
                                    <span class="value-display" id="keypointPercentileTopValue">5%</span>
                                </div>
                                <span class="value-display" id="keypointPercentileValue">5%</span>
                            </div>
                        </div>
                        
                        <div class="filter-item">
                            <div class="filter-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="enablePercentile">
                                    <span class="checkmark"></span>
                                    Minimum Matches Filter
                                </label>
                                <p class="filter-description">
                                    <strong>What it does:</strong> Filters based on number of matches per image pair<br>
                                    <strong>Method:</strong> Counts matches per pair and removes pairs with too few matches<br>
                                    <strong>Logic:</strong> Removes entire image pairs that have fewer than X matches<br>
                                    <strong>Example:</strong> 10 means it removes any image pair that has fewer than 10 keypoint matches<br>
                                    <strong>Purpose:</strong> Removes poor quality image pairs (where feature detection failed)
                                </p>
                            </div>
                            <div class="filter-params" id="percentileParam" style="display: none;">
                                <label>Minimum Matches:</label>
                                <input type="number" id="pairPercentile" value="10" min="1" max="1000" step="1">
                                <span class="value-display" id="pairPercentileValue">10 matches</span>
                            </div>
                        </div>
                        
                        <div class="filter-item">
                            <div class="filter-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="enableStdDev">
                                    <span class="checkmark"></span>
                                    Standard Deviation Filter
                                </label>
                                <p class="filter-description"><strong>What it does:</strong> Filters based on statistical outliers using standard deviation<br>
                                    <strong>Method:</strong> Uses np.std() to calculate standard deviation and removes matches beyond Xσ from mean<br>
                                    <strong>Logic:</strong> Removes matches with speeds more than X standard deviations away from the mean speed<br>
                                    <strong>Example:</strong> 2.0σ means it removes matches with speeds >2 standard deviations from the mean<br>
                                    <strong>Purpose:</strong> Removes extreme statistical outliers (very unusual speeds that might be errors)</p>
                            </div>
                            <div class="filter-params" id="stdDevParam" style="display: none;">
                                <label>Std Dev Multiplier:</label>
                                <input type="number" id="stdDevMultiplier" value="2.0" min="0.1" max="5.0" step="1">
                                <span class="value-display" id="stdDevMultiplierValue">2.0σ</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Image Quality Filters -->
                <div class="filter-category">
                    <h4 class="category-title">🌤️ Image Quality Filters</h4>
                    <p class="category-description">Filter based on image characteristics and cloudiness</p>
                    
                    <div class="filter-grid">
                        <div class="filter-item">
                            <div class="filter-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="enableCloudiness">
                                    <span class="checkmark"></span>
                                    Cloudiness Filter
                                </label>
                                <p class="filter-description"><strong>What it does:</strong> Filters based on image brightness and contrast to categorize cloudiness<br>
                                    <strong>Method:</strong> Analyzes image properties (brightness, contrast) to classify image quality<br>
                                    <strong>Logic:</strong> Clear images have high brightness/contrast, cloudy images have low brightness/contrast<br>
                                    <strong>Example:</strong> Clear: brightness ≥120 Filters based on image brightness and contrast to remove cloudy images. Clear: high brightness (≥120) and contrast (≥55). Cloudy: low brightness (≤60) or contrast (≤40). contrast ≥55, Cloudy: brightness ≤60 or contrast ≤40<br>
                                    <strong>Purpose:</strong> Removes poor quality images (cloudy/overcast conditions that affect ISS visibility)</p>
                            </div>
                            <div class="filter-params" id="cloudinessParams" style="display: none;">
                                <div class="settings-grid">
                                    <div class="setting-group">
                                        <h5>Clear Image Thresholds</h5>
                                        <div class="setting-item">
                                            <label>Brightness Min:</label>
                                            <input type="number" id="clearBrightnessMin" value="120" min="0" max="255" step="1">
                                            <span class="value-display" id="clearBrightnessMinValue">120</span>
                                        </div>
                                        <div class="setting-item">
                                            <label>Contrast Min:</label>
                                            <input type="number" id="clearContrastMin" value="55" min="0" max="100" step="1">
                                            <span class="value-display" id="clearContrastMinValue">55</span>
                                        </div>
                                    </div>
                                    
                                    <div class="setting-group">
                                        <h5>Cloudy Image Thresholds</h5>
                                        <div class="setting-item">
                                            <label>Brightness Max:</label>
                                            <input type="number" id="cloudyBrightnessMax" value="60" min="0" max="255" step="1">
                                            <span class="value-display" id="cloudyBrightnessMaxValue">60</span>
                                        </div>
                                        <div class="setting-item">
                                            <label>Contrast Max:</label>
                                            <input type="number" id="cloudyContrastMax" value="40" min="0" max="100" step="1">
                                            <span class="value-display" id="cloudyContrastMaxValue">40</span>
                                        </div>
                                    </div>
                                    
                                    <div class="setting-group">
                                        <h5>Include Categories</h5>
                                        <div class="checkbox-group">
                                            <label class="checkbox-label">
                                                <input type="checkbox" id="includePartlyCloudy" checked>
                                                <span class="checkmark"></span>
                                                Include Partly Cloudy
                                            </label>
                                            <label class="checkbox-label">
                                                <input type="checkbox" id="includeMostlyCloudy" checked>
                                                <span class="checkmark"></span>
                                                Include Mostly Cloudy
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="filter-item">
                            <div class="filter-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="enableMLClassification">
                                    <span class="checkmark"></span>
                                    ML Classification Filter
                                </label>
                                <p class="filter-description"><strong>What it does:</strong> Uses machine learning to classify images based on quality<br>
                                    <strong>Method:</strong> Applies trained ML model to analyze image features and predict quality<br>
                                    <strong>Logic:</strong> Classifies images as "Good" (high quality) or "Not_Good" (low quality)<br>
                                    <strong>Example:</strong> Good: clear ISS visibility, Not_Good: poor visibility due to clouds/lighting<br>
                                    <strong>Purpose:</strong> Removes low quality images using automated ML classification</p>
                            </div>
                            <div class="filter-params" id="mlClassificationParams" style="display: none;">
                                <div class="checkbox-group">
                                    <label class="checkbox-label">
                                        <input type="checkbox" id="includeGood" checked>
                                        <span class="checkmark"></span>
                                        Include Good Images
                                    </label>
                                    <label class="checkbox-label">
                                        <input type="checkbox" id="includeNotGood" checked>
                                        <span class="checkmark"></span>
                                        Include Not_Good Images
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- GSD Configuration -->
            <div class="filter-category">
                <h4 class="category-title">🛰️ Ground Sample Distance (GSD) Configuration</h4>
                <p class="category-description">Configure the Ground Sample Distance used for speed calculations. GSD represents the distance between pixel centers measured on the ground.</p>
                
                <div class="filter-grid">
                    <div class="filter-item">
                        <div class="filter-header">
                            <label class="checkbox-label">
                                <input type="checkbox" id="enableCustomGSD">
                                <span class="checkmark"></span>
                                Custom GSD Value
                            </label>
                            <p class="filter-description"><strong>What it does:</strong> Override the default Ground Sample Distance (GSD) value<br>
                            <strong>Method:</strong> Allows manual input of custom GSD value in cm/pixel<br>
                            <strong>Logic:</strong> Replaces default GSD (12648 cm/pixel) with user-specified value for speed calculations<br>
                            <strong>Example:</strong> 10000 cm/pixel = 100m per pixel (higher altitude), 15000 cm/pixel = 150m per pixel (lower altitude)<br>
                            <strong>Purpose:</strong> Adjust speed calculations for different camera setups, altitudes, or ISS positions</p>
                        </div>
                        <div class="filter-params" id="customGSDParam" style="display: none;">
                            <label>GSD Value (cm/pixel):</label>
                            <input type="number" id="customGSD" value="12648" min="1000" max="50000" step="1">
                            <span class="value-display" id="customGSDValue">12648 cm/pixel</span>
                            <div class="gsd-info">
                                <small>Default: 12648 cm/pixel (ESA ISS altitude ~400km)<br>
                                Lower values = higher altitude, Higher values = lower altitude</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="filter-actions">
                <button class="btn btn-primary" id="refreshBtn" onclick="refreshData()" disabled>
                    <span class="btn-icon">🔄</span>
                    Apply Filters & Refresh Data
                </button>
                <button class="btn btn-secondary" onclick="resetFilters()">
                    <span class="btn-icon">↺</span>
                    Reset All Filters
                </button>
            </div>
        </div>

        <!-- Section 5: Speed Distribution Graph -->
        <div class="section">
            <div class="section-title">Section 5: Speed Distribution (Histogram)</div>
            <div id="speedPlot" class="plot-container"></div>
        </div>

        <!-- Section 6: Pair Analysis Graph -->
        <div class="section">
            <div class="section-title">Section 6: Pair Analysis - Mean & Median (Click dots to view details)</div>
            <div id="legendContainer" class="legend-container" style="margin-bottom: 10px; padding: 10px; background-color: #f8f9fa; border-radius: 5px; display: none;">
                <div class="legend-title" style="font-weight: bold; margin-bottom: 5px;">Legend:</div>
                <div id="legendContent" class="legend-content"></div>
            </div>
            <div id="pairPlot" class="plot-container"></div>
        </div>

        <!-- Section 7: Algorithm Comparison -->
        <div class="section">
            <div class="section-title">Section 7: Algorithm Comparison
                <div class="tooltip">
                    <span class="help-icon">?</span>
                    <div class="tooltip-content">
                        <div class="tooltip-title">Algorithm Comparison</div>
                        <div class="tooltip-text">Compare different ISS speed calculation algorithms on the same dataset. Includes GitHub projects and other implementations for performance comparison.</div>
                        <div class="tooltip-example">This helps evaluate which approach works best for your specific images and conditions.</div>
                    </div>
                </div>
            </div>
            
            <!-- Algorithm Selection -->
            <div class="comparison-categories">
                <div class="comparison-category">
                    <h4 class="category-title">🔬 Algorithm Selection</h4>
                    <p class="category-description">Choose which algorithms to compare against your current results</p>
                    
                    <div class="algorithm-grid">
                        <div class="algorithm-item">
                            <div class="algorithm-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="compareGithubCV" checked>
                                    <span class="checkmark"></span>
                                    GitHub Computer Vision
                                </label>
                                <div class="tooltip">
                                    <span class="help-icon">?</span>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">GitHub Computer Vision (diyasmenon/astropi)</div>
                                        <div class="tooltip-text">Basic ORB feature detection with simple outlier removal. A straightforward computer vision approach.</div>
                                        <div class="tooltip-example">Good baseline for comparison with more sophisticated methods.</div>
                                    </div>
                                </div>
                            </div>
                            <div class="algorithm-description">
                                <strong>Method:</strong> Basic ORB feature detection<br>
                                <strong>Approach:</strong> Simple outlier removal<br>
                                <strong>Complexity:</strong> Low
                            </div>
                        </div>
                        
                        <div class="algorithm-item">
                            <div class="algorithm-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="compareGPS" checked>
                                    <span class="checkmark"></span>
                                    GPS-based Method
                                </label>
                                <div class="tooltip">
                                    <span class="help-icon">?</span>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">GPS-based (Cossack42/AstroPI)</div>
                                        <div class="tooltip-text">Uses GPS coordinates and time difference to calculate speed directly. The winning approach from the competition.</div>
                                        <div class="tooltip-example">Most accurate method, but requires GPS data in images.</div>
                                    </div>
                                </div>
                            </div>
                            <div class="algorithm-description">
                                <strong>Method:</strong> GPS coordinate calculation<br>
                                <strong>Approach:</strong> Direct distance/time calculation<br>
                                <strong>Complexity:</strong> Low
                            </div>
                        </div>
                        
                        <div class="algorithm-item">
                            <div class="algorithm-header">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="compareCchan083" checked>
                                    <span class="checkmark"></span>
                                    SIFT-based Method
                                </label>
                                <div class="tooltip">
                                    <span class="help-icon">?</span>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">SIFT-based (cchan083/AstroPi)</div>
                                        <div class="tooltip-text">Uses SIFT feature detection with grayscale processing. Achieved 98.75% accuracy in testing.</div>
                                        <div class="tooltip-example">High accuracy but slower processing due to SIFT algorithm complexity.</div>
                                    </div>
                                </div>
                            </div>
                            <div class="algorithm-description">
                                <strong>Method:</strong> SIFT feature detection<br>
                                <strong>Approach:</strong> Grayscale processing + brute force matching<br>
                                <strong>Complexity:</strong> High (slower but accurate)
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Progress Bar -->
            <div class="comparison-progress" id="comparisonProgress" style="display: none;">
                <h4 class="category-title">📊 Comparison Progress</h4>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="comparisonProgressFill"></div>
                    </div>
                    <div class="progress-text" id="comparisonProgressText">Starting comparison...</div>
                </div>
            </div>
            
            <!-- Results Display -->
            <div class="comparison-results">
                <h4 class="category-title">📊 Comparison Results</h4>
                <div id="algorithmComparisonContainer">
                    <div class="loading">
                        <div class="loading-icon">⚡</div>
                        <div class="loading-text">Click "Run Algorithm Comparison" to see results</div>
                        <div class="loading-subtext">This will test the selected algorithms on your current dataset</div>
                    </div>
                </div>
            </div>
            
            <!-- Action Button -->
            <div class="comparison-actions">
                <button id="runAlgorithmComparison" class="btn btn-primary btn-large" onclick="runAlgorithmComparison()" disabled>
                    <span class="btn-icon">🔬</span>
                    Run Algorithm Comparison
                </button>
            </div>
        </div>
    </div>
    
    <!-- Modal for displaying pair images -->
    <div id="imageModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2 id="modalTitle">Pair Details</h2>
            <div id="modalContent"></div>
        </div>
    </div>

    <script>
        let currentData = null;
        let filteredData = null;
        let selectedFolderHandle = null; // Store the selected folder handle

        // Load folders on page load
        window.onload = function() {
            detectEnvironment();
            loadFolders();
            setupFilterEventListeners();
            setupRangeSliders();
            setupTooltips();
            checkAndEnableRefreshButton();
        };

        // Environment detection and UI setup
        async function detectEnvironment() {
            try {
                const response = await fetch('/api/environment');
                const env = await response.json();
                
                console.log('🌍 Environment detected:', env);
                
                // Always use local UI version (hide file upload section)
                document.getElementById('railwayFileUpload').style.display = 'none';
                console.log('🏠 Using local UI version: Folder selection enabled in dropdown');
                
            } catch (error) {
                console.error('❌ Error detecting environment:', error);
                // Default to local UI version
                document.getElementById('railwayFileUpload').style.display = 'none';
            }
        }
        
        async function checkAndEnableRefreshButton() {
            try {
                const response = await fetch('/api/statistics');
                if (response.ok) {
                    const stats = await response.json();
                    if (stats && stats.total_matches > 0) {
                        const refreshBtn = document.getElementById('refreshBtn');
                        if (refreshBtn) {
                            refreshBtn.disabled = false;
                            console.log('✅ Refresh button enabled on page load - data is available');
                        }
                    }
                }
            } catch (error) {
                console.log('ℹ️ No data available on page load - refresh button remains disabled');
            }
        }
        
        function setupTooltips() {
            // Add click event listeners to all help icons
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('help-icon')) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Close any open tooltips
                    document.querySelectorAll('.tooltip.show').forEach(tooltip => {
                        tooltip.classList.remove('show');
                    });
                    
                    // Toggle current tooltip
                    const tooltip = e.target.closest('.tooltip');
                    if (tooltip) {
                        tooltip.classList.toggle('show');
                    }
                } else {
                    // Close all tooltips when clicking elsewhere
                    document.querySelectorAll('.tooltip.show').forEach(tooltip => {
                        tooltip.classList.remove('show');
                    });
                }
            });
        }
        
        function setupRangeSliders() {
            const startSlider = document.getElementById('startIdx');
            const endSlider = document.getElementById('endIdx');
            const startLabel = document.getElementById('startLabel');
            const endLabel = document.getElementById('endLabel');
            const rangeInfo = document.getElementById('rangeInfo');
            
            // Initially disable sliders until folder is selected
            startSlider.disabled = true;
            endSlider.disabled = true;
            startSlider.max = 0;
            endSlider.max = 0;
            startSlider.value = 0;
            endSlider.value = 0;
            
            window.updateLabels = function() {
                const startValue = parseInt(startSlider.value);
                const endValue = parseInt(endSlider.value);
                
                // Update the large number displays
                startLabel.textContent = startValue;
                endLabel.textContent = endValue;
                
                // Update the range info
                const imageCount = endValue - startValue + 1;
                if (startSlider.disabled) {
                    rangeInfo.textContent = 'Select a photo folder first';
                } else {
                    rangeInfo.textContent = `Processing ${imageCount} image${imageCount !== 1 ? 's' : ''} (${startValue}-${endValue})`;
                }
                
                // Ensure start is always less than end
                if (startValue >= endValue && !startSlider.disabled) {
                    if (startSlider === document.activeElement) {
                        endSlider.value = Math.min(parseInt(endSlider.max), startValue + 1);
                    } else {
                        startSlider.value = Math.max(parseInt(startSlider.min), endValue - 1);
                    }
                    // Don't call updateLabels recursively - just update the display directly
                    const newStartValue = parseInt(startSlider.value);
                    const newEndValue = parseInt(endSlider.value);
                    startLabel.textContent = newStartValue;
                    endLabel.textContent = newEndValue;
                    const imageCount = newEndValue - newStartValue + 1;
                    rangeInfo.textContent = `Processing ${imageCount} image${imageCount !== 1 ? 's' : ''} (${newStartValue}-${newEndValue})`;
                }
            }
            
            function updateSliderMax() {
                const totalImages = parseInt(document.getElementById('totalImages').textContent);
                
                if (totalImages && totalImages > 0) {
                    const maxValue = totalImages - 1;
                    
                    // Enable sliders and set max values
                    startSlider.disabled = false;
                    endSlider.disabled = false;
                    startSlider.max = maxValue;
                    endSlider.max = maxValue;
                    
                    // Set reasonable default values
                    startSlider.value = 0;
                    endSlider.value = Math.min(9, maxValue); // Default to first 10 images or max available
                    
                    window.updateLabels();
                } else {
                    // Disable sliders if no folder selected
                    startSlider.disabled = true;
                    endSlider.disabled = true;
                    startSlider.max = 0;
                    endSlider.max = 0;
                    startSlider.value = 0;
                    endSlider.value = 0;
                    window.updateLabels();
                }
            }
            
            // Add event listeners
            startSlider.addEventListener('input', updateLabels);
            endSlider.addEventListener('input', updateLabels);
            
            // Update max values when total images changes
            const totalImagesElement = document.getElementById('totalImages');
            const observer = new MutationObserver(updateSliderMax);
            observer.observe(totalImagesElement, { childList: true, characterData: true, subtree: true });
            
            // Initial setup
            updateLabels();
        }

        function setupFilterEventListeners() {
            // Show/hide filter parameters based on checkbox state
            const enableKeypointPercentile = document.getElementById('enableKeypointPercentile');
            if (enableKeypointPercentile) {
                enableKeypointPercentile.addEventListener('change', function() {
                    const params = document.getElementById('keypointPercentileParam');
                    if (params) {
                        if (this.checked) {
                            params.style.display = 'flex';
                        } else {
                            params.style.display = 'none';
                        }
                    }
                });
            }

            const enablePercentile = document.getElementById('enablePercentile');
            if (enablePercentile) {
                enablePercentile.addEventListener('change', function() {
                    const params = document.getElementById('percentileParam');
                    if (params) {
                        if (this.checked) {
                            params.style.display = 'flex';
                        } else {
                            params.style.display = 'none';
                        }
                    }
                });
            }

            const enableStdDev = document.getElementById('enableStdDev');
            if (enableStdDev) {
                enableStdDev.addEventListener('change', function() {
                    const params = document.getElementById('stdDevParam');
                    if (params) {
                        if (this.checked) {
                            params.style.display = 'flex';
                        } else {
                            params.style.display = 'none';
                        }
                    }
                });
            }

            const enableCloudiness = document.getElementById('enableCloudiness');
            if (enableCloudiness) {
                enableCloudiness.addEventListener('change', function() {
                    const params = document.getElementById('cloudinessParams');
                    const params2 = document.getElementById('cloudinessParams2');
                    const mlCheckbox = document.getElementById('enableMLClassification');
                    const mlParams = document.getElementById('mlClassificationParams');
                    
                    if (this.checked) {
                        // Disable ML classification when cloudiness is enabled
                        if (mlCheckbox) mlCheckbox.checked = false;
                        if (mlParams) mlParams.style.display = 'none';
                        
                        // Show cloudiness parameters
                        if (params) params.style.display = 'flex';
                        if (params2) params2.style.display = 'flex';
                    } else {
                        if (params) params.style.display = 'none';
                        if (params2) params2.style.display = 'none';
                    }
                    
                    // Update legend immediately
                    updateLegend();
                });
            }
            
            const enableMLClassification = document.getElementById('enableMLClassification');
            if (enableMLClassification) {
                enableMLClassification.addEventListener('change', function() {
                    const params = document.getElementById('mlClassificationParams');
                    const cloudinessCheckbox = document.getElementById('enableCloudiness');
                    const cloudinessParams = document.getElementById('cloudinessParams');
                    const cloudinessParams2 = document.getElementById('cloudinessParams2');
                    
                    if (this.checked) {
                        // Disable cloudiness when ML classification is enabled
                        if (cloudinessCheckbox) cloudinessCheckbox.checked = false;
                        if (cloudinessParams) cloudinessParams.style.display = 'none';
                        if (cloudinessParams2) cloudinessParams2.style.display = 'none';
                        
                        // Show ML parameters
                        if (params) params.style.display = 'flex';
                    } else {
                        if (params) params.style.display = 'none';
                    }
                    
                    // Update legend immediately
                    updateLegend();
                });
            }

            // Update value displays
            const keypointPercentileBottom = document.getElementById('keypointPercentileBottom');
            if (keypointPercentileBottom) {
                keypointPercentileBottom.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('keypointPercentileBottomValue');
                    if (valueDisplay) valueDisplay.textContent = this.value + '%';
                });
            }

            const keypointPercentileTop = document.getElementById('keypointPercentileTop');
            if (keypointPercentileTop) {
                keypointPercentileTop.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('keypointPercentileTopValue');
                    if (valueDisplay) valueDisplay.textContent = this.value + '%';
                });
            }

            const pairPercentile = document.getElementById('pairPercentile');
            if (pairPercentile) {
                pairPercentile.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('pairPercentileValue');
                    if (valueDisplay) valueDisplay.textContent = this.value + ' matches';
                });
            }

            const stdDevMultiplier = document.getElementById('stdDevMultiplier');
            if (stdDevMultiplier) {
                stdDevMultiplier.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('stdDevMultiplierValue');
                    if (valueDisplay) valueDisplay.textContent = this.value + 'σ';
                });
            }

            const clearBrightnessMin = document.getElementById('clearBrightnessMin');
            if (clearBrightnessMin) {
                clearBrightnessMin.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('clearBrightnessMinValue');
                    if (valueDisplay) valueDisplay.textContent = this.value;
                    
                    // Log cloudiness filter change
                    logAction('CLOUDINESS_FILTER_CHANGED', {
                        parameter: 'clearBrightnessMin',
                        newValue: this.value,
                        enabled: document.getElementById('enableCloudiness')?.checked || false
                    });
                });
            }

            const clearContrastMin = document.getElementById('clearContrastMin');
            if (clearContrastMin) {
                clearContrastMin.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('clearContrastMinValue');
                    if (valueDisplay) valueDisplay.textContent = this.value;
                    
                    // Log cloudiness filter change
                    logAction('CLOUDINESS_FILTER_CHANGED', {
                        parameter: 'clearContrastMin',
                        newValue: this.value,
                        enabled: document.getElementById('enableCloudiness')?.checked || false
                    });
                });
            }

            const cloudyBrightnessMax = document.getElementById('cloudyBrightnessMax');
            if (cloudyBrightnessMax) {
                cloudyBrightnessMax.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('cloudyBrightnessMaxValue');
                    if (valueDisplay) valueDisplay.textContent = this.value;
                    
                    // Log cloudiness filter change
                    logAction('CLOUDINESS_FILTER_CHANGED', {
                        parameter: 'cloudyBrightnessMax',
                        newValue: this.value,
                        enabled: document.getElementById('enableCloudiness')?.checked || false
                    });
                });
            }

            const cloudyContrastMax = document.getElementById('cloudyContrastMax');
            if (cloudyContrastMax) {
                cloudyContrastMax.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('cloudyContrastMaxValue');
                    if (valueDisplay) valueDisplay.textContent = this.value;
                    
                    // Log cloudiness filter change
                    logAction('CLOUDINESS_FILTER_CHANGED', {
                        parameter: 'cloudyContrastMax',
                        newValue: this.value,
                        enabled: document.getElementById('enableCloudiness')?.checked || false
                    });
                });
            }

            // GSD Configuration event listeners
            const enableCustomGSD = document.getElementById('enableCustomGSD');
            if (enableCustomGSD) {
                enableCustomGSD.addEventListener('change', function() {
                    const params = document.getElementById('customGSDParam');
                    if (params) {
                        if (this.checked) {
                            params.style.display = 'block';
                        } else {
                            params.style.display = 'none';
                        }
                    }
                    
                    // Log GSD toggle
                    logAction('GSD_TOGGLE', {
                        enabled: this.checked,
                        currentValue: document.getElementById('customGSD')?.value || '12648'
                    });
                });
            }

            const customGSD = document.getElementById('customGSD');
            if (customGSD) {
                customGSD.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('customGSDValue');
                    if (valueDisplay) valueDisplay.textContent = this.value + ' cm/pixel';
                    
                    // Log GSD change
                    logAction('GSD_VALUE_CHANGED', {
                        newValue: this.value,
                        enabled: document.getElementById('enableCustomGSD')?.checked || false
                    });
                });
            }
            
            // Homography filter event listeners (moved to Section 2)
            const useRansacHomography = document.getElementById('useRansacHomography');
            if (useRansacHomography) {
                useRansacHomography.addEventListener('change', function() {
                    const params = document.getElementById('ransacHomographyParams');
                    if (params) {
                        if (this.checked) {
                            params.style.display = 'flex';
                        } else {
                            params.style.display = 'none';
                        }
                    }
                });
            }
            
            const ransacThreshold = document.getElementById('ransacThreshold');
            if (ransacThreshold) {
                ransacThreshold.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('ransacThresholdValue');
                    if (valueDisplay) valueDisplay.textContent = this.value;
                });
            }
            
            const ransacMinMatches = document.getElementById('ransacMinMatches');
            if (ransacMinMatches) {
                ransacMinMatches.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('ransacMinMatchesValue');
                    if (valueDisplay) valueDisplay.textContent = this.value;
                });
            }
            
            // Maximum Features event listener
            const maxFeatures = document.getElementById('maxFeatures');
            if (maxFeatures) {
                maxFeatures.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('maxFeaturesValue');
                    if (valueDisplay) valueDisplay.textContent = this.value;
                });
            }
        }

        async function loadFolders() {
            try {
                const response = await fetch('/api/folders');
                const folders = await response.json();
                
                console.log('📁 Loaded folders:', folders);
                
                const select = document.getElementById('folderSelect');
                select.innerHTML = '<option value="">Select a folder...</option>';
                
                folders.forEach(folder => {
                    console.log('📁 Processing folder:', folder.name, 'count:', folder.count);
                    const option = document.createElement('option');
                    option.value = folder.name;
                    // Use display_name if available (for uploaded folders), otherwise use folder name
                    const displayText = folder.display_name || `${folder.name} (${folder.count || 0} images)`;
                    option.textContent = displayText;
                    select.appendChild(option);
                });
                
                // Show helpful message if no folders found
                const noFoldersMessage = document.getElementById('noFoldersMessage');
                if (folders.length === 0) {
                    if (noFoldersMessage) {
                        noFoldersMessage.style.display = 'block';
                    }
                } else {
                    if (noFoldersMessage) {
                        noFoldersMessage.style.display = 'none';
                    }
                }
                
                // Add the "Choose folder from device..." option at the end (only for local)
                const railwayUpload = document.getElementById('railwayFileUpload');
                if (railwayUpload && railwayUpload.style.display === 'none') {
                    // Only add folder selection option if we're in local environment
                    const selectFolderOption = document.createElement('option');
                    selectFolderOption.value = 'select_folder';
                    selectFolderOption.textContent = '📁 Choose folder from device...';
                    select.appendChild(selectFolderOption);
                }
                
                console.log('📁 Folder dropdown populated successfully');
            } catch (error) {
                console.error('❌ Error loading folders:', error);
            }
        }

        // Folder selection functionality (local only)
        document.getElementById('folderSelect').addEventListener('change', function(e) {
            if (e.target.value === 'select_folder') {
                selectFolderFromDevice();
            }
        });

        // File upload functionality (Railway only)
        document.getElementById('fileUpload').addEventListener('change', function(e) {
            const files = e.target.files;
            if (files.length > 0) {
                uploadFiles(files);
            }
        });


        async function selectFolderFromDevice() {
            try {
                // Use the File System Access API if available (modern browsers)
                if ('showDirectoryPicker' in window) {
                    const directoryHandle = await window.showDirectoryPicker();
                    const folderInfo = await processSelectedFolder(directoryHandle);
                    if (folderInfo) {
                        // Store the folder handle globally
                        selectedFolderHandle = directoryHandle;
                        
                        // Reload folders to include the uploaded folder
                        await loadFolders();
                        
                        // Select the new folder
                        const select = document.getElementById('folderSelect');
                        select.value = folderInfo.id;
                        select.dispatchEvent(new Event('change'));
                    }
                } else {
                    // Fallback for older browsers - show a message
                    alert('Folder selection is not supported in this browser. Please use a modern browser like Chrome, Edge, or Firefox.');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Folder selection error:', error);
                    alert('Error selecting folder: ' + error.message);
                }
            }
        }

        async function processSelectedFolder(directoryHandle) {
            try {
                // Get the original folder name
                const originalFolderName = directoryHandle.name || 'Unknown Folder';
                
                // Count image files in the selected folder
                let imageCount = 0;
                const imageExtensions = ['.jpg', '.jpeg', '.png', '.tiff', '.tif'];
                const imageFiles = [];
                
                for await (const [name, handle] of directoryHandle.entries()) {
                    if (handle.kind === 'file') {
                        const ext = name.toLowerCase().substring(name.lastIndexOf('.'));
                        if (imageExtensions.includes(ext)) {
                            imageCount++;
                            imageFiles.push({ name, handle });
                        }
                    }
                }
                
                if (imageCount === 0) {
                    alert('No image files found in the selected folder. Please select a folder containing JPG, PNG, or TIFF images.');
                    return null;
                }
                
                // Show progress message
                const progressMsg = `📤 Uploading ${imageCount} images from "${originalFolderName}" to server...`;
                alert(progressMsg);
                
                // Upload images to server with original folder name
                const uploadResult = await uploadFolderToServer(directoryHandle, imageFiles, originalFolderName);
                
                if (uploadResult.success) {
                    // Create folder info for the uploaded folder
                    const folderInfo = {
                        id: uploadResult.folder_path,
                        name: `${originalFolderName} (${imageCount} images)`,
                        count: imageCount,
                        uploaded: true
                    };
                    
                    alert(`✅ Successfully uploaded ${imageCount} images from "${originalFolderName}"! Ready for analysis.`);
                    return folderInfo;
                } else {
                    alert(`❌ Upload failed: ${uploadResult.error}`);
                    return null;
                }
                
            } catch (error) {
                console.error('Error processing folder:', error);
                alert(`❌ Error processing folder: ${error.message}`);
                return null;
            }
        }

        async function uploadFolderToServer(directoryHandle, imageFiles, originalFolderName) {
            try {
                const formData = new FormData();
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                
                // Create a safe folder name with original name + timestamp
                const safeOriginalName = originalFolderName.replace(/[^a-zA-Z0-9_-]/g, '_');
                const folderName = `${safeOriginalName}_${timestamp}`;
                
                // Add folder name
                formData.append('folder_name', folderName);
                formData.append('original_folder_name', originalFolderName);
                
                // Upload each image file
                for (const fileInfo of imageFiles) {
                    const file = await fileInfo.handle.getFile();
                    formData.append('files', file);
                }
                
                const response = await fetch('/api/upload-folder', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                return result;
                
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // File upload function for Railway environments
        async function uploadFiles(files) {
            const uploadStatus = document.getElementById('uploadStatus');
            const folderNameInput = document.getElementById('folderNameInput');
            
            // Show upload status
            uploadStatus.style.display = 'block';
            uploadStatus.innerHTML = '<div style="color: #007bff;">📤 Uploading files...</div>';
            
            try {
                const formData = new FormData();
                
                // Add files to form data
                for (let i = 0; i < files.length; i++) {
                    formData.append('files', files[i]);
                }
                
                // Add folder name if provided
                const folderName = folderNameInput.value.trim() || 'uploaded_photos';
                formData.append('folder_name', folderName);
                
                const response = await fetch('/api/upload-folder', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    uploadStatus.innerHTML = `<div style="color: #28a745;">✅ ${result.message}</div>`;
                    
                    // Clear the file input
                    document.getElementById('fileUpload').value = '';
                    folderNameInput.value = '';
                    
                    // Reload folders to include the new upload
                    await loadFolders();
                    
                    // Auto-select the newly uploaded folder
                    const select = document.getElementById('folderSelect');
                    for (let option of select.options) {
                        if (option.value === result.folder_path) {
                            option.selected = true;
                            select.dispatchEvent(new Event('change'));
                            break;
                        }
                    }
                    
                    // Hide status after 3 seconds
                    setTimeout(() => {
                        uploadStatus.style.display = 'none';
                    }, 3000);
                    
                } else {
                    uploadStatus.innerHTML = `<div style="color: #dc3545;">❌ Upload failed: ${result.error || 'Unknown error'}</div>`;
                }
                
            } catch (error) {
                console.error('Upload error:', error);
                uploadStatus.innerHTML = `<div style="color: #dc3545;">❌ Upload failed: ${error.message}</div>`;
            }
        }

        function addSelectedFolderToDropdown(folderInfo) {
            const select = document.getElementById('folderSelect');
            
            // Create new option
            const option = document.createElement('option');
            option.value = folderInfo.id;
            option.textContent = folderInfo.name;
            
            // Insert before the "Choose folder from device..." option
            const selectFolderOption = select.querySelector('option[value="select_folder"]');
            if (selectFolderOption) {
                select.insertBefore(option, selectFolderOption);
            } else {
                select.appendChild(option);
            }
            
            // Update total images display
            const totalImagesElement = document.getElementById('totalImages');
            if (totalImagesElement) {
                totalImagesElement.textContent = folderInfo.count;
            }
        }

        // Update total images when folder changes
        const folderSelect = document.getElementById('folderSelect');
        if (folderSelect) {
            folderSelect.addEventListener('change', function() {
                const selectedOption = this.options[this.selectedIndex];
                if (selectedOption.value && selectedOption.value !== 'select_folder') {
                    // Check if it's a selected folder (starts with 'selected_folder_')
                    if (selectedOption.value.startsWith('selected_folder_')) {
                        // For selected folders, we already have the count stored
                        const totalImagesElement = document.getElementById('totalImages');
                        if (totalImagesElement) {
                            const match = selectedOption.textContent.match(/\((\d+) images\)/);
                            if (match) {
                                totalImagesElement.textContent = match[1];
                            }
                        }
                    } else {
                        // For regular folders, extract count from text
                        const match = selectedOption.textContent.match(/\((\d+) images\)/);
                        if (match) {
                            const totalImages = parseInt(match[1]);
                            const totalImagesElement = document.getElementById('totalImages');
                            if (totalImagesElement) totalImagesElement.textContent = totalImages;
                        }
                    }
                    
                    // Ensure sliders are updated
                    if (typeof updateSliderMax === 'function') {
                        updateSliderMax();
                    }
                } else {
                    const totalImagesElement = document.getElementById('totalImages');
                    if (totalImagesElement) totalImagesElement.textContent = '-';
                        
                    // Ensure sliders are updated
                    if (typeof updateSliderMax === 'function') {
                        updateSliderMax();
                    }
                }
                window.updateLabels();
            });
        }

        async function loadData() {
            // Reset all states to fresh start
            resetAllStates();
            
            const folder = document.getElementById('folderSelect').value;
            const startIdx = parseInt(document.getElementById('startIdx').value);
            const endIdx = parseInt(document.getElementById('endIdx').value);
            const algorithm = document.getElementById('algorithmSelect').value;
            const useFlann = document.getElementById('useFlann').checked;
            const useRansacHomography = document.getElementById('useRansacHomography').checked;
            const contrastEnhancement = document.getElementById('contrastEnhancement').value;
            
            // Log the data loading action
            logAction('LOAD_DATA', {
                folder: folder,
                startIdx: startIdx,
                endIdx: endIdx,
                algorithm: algorithm,
                useFlann: useFlann,
                useRansacHomography: useRansacHomography,
                contrastEnhancement: contrastEnhancement,
                maxFeatures: document.getElementById('maxFeatures').value
            });
            const ransacThreshold = parseFloat(document.getElementById('ransacThreshold').value);
            const ransacMinMatches = parseInt(document.getElementById('ransacMinMatches').value);
            const maxFeatures = parseInt(document.getElementById('maxFeatures').value);

            if (!folder) {
                alert('Please select a folder');
                return;
            }

            if (startIdx >= endIdx) {
                alert('Start index must be less than end index');
                return;
            }

            // Show loading and progress bar
            document.getElementById('statisticsContainer').innerHTML = '<div class="loading">Processing images... This may take a while.</div>';
            document.getElementById('loadBtn').disabled = true;
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = 'Starting processing...';

            // Start progress monitoring
            const progressInterval = setInterval(updateProgress, 500);

            try {
                const response = await fetch('/api/process-range', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        folder: folder,
                        start_idx: startIdx,
                        end_idx: endIdx,
                algorithm: algorithm,
                use_flann: useFlann,
                use_ransac_homography: useRansacHomography,
                ransac_threshold: ransacThreshold,
                ransac_min_matches: ransacMinMatches,
                contrast_enhancement: contrastEnhancement,
                max_features: maxFeatures
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Clear any frontend filter state before loading statistics
                    // This ensures we show raw data when loading from cache
                    console.log('🔄 Clearing frontend filter state before loading statistics');
                    
                    // Load statistics
                    await loadStatistics();
                    document.getElementById('refreshBtn').disabled = false;
                    
                    // Load plot data to show the graphs
                    await updatePlots();
                    
                    if (result.from_cache) {
                        showMessage(`🚀 Loaded ${result.total_matches} matches from cache!`, 'success');
                    } else {
                        showMessage(`✅ Successfully processed ${result.pairs_processed} pairs with ${result.total_matches} total matches`, 'success');
                    }
                } else {
                    showMessage('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('Error: ' + error.message, 'error');
            } finally {
                clearInterval(progressInterval);
                document.getElementById('loadBtn').disabled = false;
                document.getElementById('progressContainer').style.display = 'none';
            }
        }

        async function updateProgress() {
            try {
                const response = await fetch('/api/processing-status');
                const status = await response.json();
                
                if (status.status === 'processing') {
                    const progress = Math.round(status.progress);
                    document.getElementById('progressFill').style.width = progress + '%';
                    document.getElementById('progressText').textContent = 
                        `Processing pair ${status.current_pair} of ${status.total_pairs} (${progress}%)`;
                } else if (status.status === 'completed') {
                    document.getElementById('progressFill').style.width = '100%';
                    document.getElementById('progressText').textContent = 'Processing completed!';
                } else if (status.status === 'error') {
                    document.getElementById('progressText').textContent = 'Processing failed!';
                }
            } catch (error) {
                console.error('Error updating progress:', error);
            }
        }

        async function loadStatistics() {
            try {
                const response = await fetch('/api/statistics');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const stats = await response.json();
                console.log('📊 Statistics received:', stats);
                
                // Log statistics update
                logAction('STATISTICS_UPDATED', {
                    statistics: stats,
                    timestamp: new Date().toISOString()
                });

                if (stats && typeof stats === 'object') {
                    displayStatistics(stats);
                    // Automatically show graphs when statistics are loaded
                    // Note: updatePlots will call /api/plot-data which will show raw data if no filters are applied
                    updatePlots(stats);
                    // Update legend
                    updateLegend();
                    
                    // Enable algorithm comparison button when data is loaded
                    document.getElementById('runAlgorithmComparison').disabled = false;
                    
                    // Enable refresh button when data is loaded
                    const refreshBtn = document.getElementById('refreshBtn');
                    if (refreshBtn) {
                        refreshBtn.disabled = false;
                        console.log('✅ Refresh button enabled - data is available for filtering');
                    }
                } else {
                    console.error('❌ Invalid statistics data:', stats);
                    document.getElementById('statisticsContainer').innerHTML = '<div class="error">No valid statistics data received</div>';
                }
            } catch (error) {
                console.error('❌ Error loading statistics:', error);
                document.getElementById('statisticsContainer').innerHTML = '<div class="error">Error loading statistics: ' + error.message + '</div>';
            }
        }

        async function runAlgorithmComparison() {
            const button = document.getElementById('runAlgorithmComparison');
            const container = document.getElementById('algorithmComparisonContainer');
            const progressContainer = document.getElementById('comparisonProgress');
            const progressFill = document.getElementById('comparisonProgressFill');
            const progressText = document.getElementById('comparisonProgressText');
            
            try {
                // Get selected algorithms
                const algorithms = [];
                if (document.getElementById('compareGithubCV').checked) {
                    algorithms.push('github_cv');
                }
                if (document.getElementById('compareGPS').checked) {
                    algorithms.push('gps');
                }
                if (document.getElementById('compareCchan083').checked) {
                    algorithms.push('cchan083');
                }
                
                if (algorithms.length === 0) {
                    container.innerHTML = '<div class="error">❌ Please select at least one algorithm to compare</div>';
                    return;
                }
                
                // Show loading state
                button.disabled = true;
                button.innerHTML = '<span class="btn-icon">🔄</span>Running Algorithm Comparison...';
                progressContainer.style.display = 'block';
                container.innerHTML = '<div class="loading">🔄 Running algorithm comparisons...</div>';
                
                // Initialize progress
                progressFill.style.width = '0%';
                progressText.textContent = 'Starting comparison...';
                
                // Start progress monitoring
                const progressInterval = setInterval(() => {
                    updateComparisonProgress();
                }, 1000);
                
                // Get current folder and range settings
                const folder = document.getElementById('folderSelect').value;
                const startIdx = parseInt(document.getElementById('startIdx').value);
                const endIdx = parseInt(document.getElementById('endIdx').value);
                
                if (!folder) {
                    showMessage('Please select a folder first', 'error');
                    return;
                }
                
                const maxFeatures = parseInt(document.getElementById('maxFeatures').value);
                
                const response = await fetch('/api/algorithm-comparison', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        folder: folder,
                        start_idx: startIdx,
                        end_idx: endIdx,
                        algorithms: algorithms,
                        max_features: maxFeatures
                    })
                });
                
                const results = await response.json();
                
                console.log('🔍 Algorithm comparison results:', results);
                
                // Clear progress monitoring
                clearInterval(progressInterval);
                
                // Check for errors
                if (results.error) {
                    showMessage('Algorithm comparison failed: ' + results.error, 'error');
                    return;
                }
                progressContainer.style.display = 'none';
                
                if (results.success) {
                    displayAlgorithmComparison(results);
                } else {
                    container.innerHTML = `<div class="error">❌ Error: ${results.error || 'Unknown error'}</div>`;
                }
                
            } catch (error) {
                console.error('Error running algorithm comparison:', error);
                container.innerHTML = `<div class="error">❌ Error: ${error.message}</div>`;
                progressContainer.style.display = 'none';
            } finally {
                button.disabled = false;
                button.innerHTML = '<span class="btn-icon">🔬</span>Run Algorithm Comparison';
            }
        }
        
        function updateComparisonProgress() {
            const progressFill = document.getElementById('comparisonProgressFill');
            const progressText = document.getElementById('comparisonProgressText');
            
            // Simulate progress (this would be updated by the backend in a real implementation)
            const currentWidth = parseInt(progressFill.style.width) || 0;
            if (currentWidth < 90) {
                const newWidth = Math.min(currentWidth + Math.random() * 10, 90);
                progressFill.style.width = newWidth + '%';
                
                if (newWidth < 30) {
                    progressText.textContent = 'Initializing algorithms...';
                } else if (newWidth < 60) {
                    progressText.textContent = 'Processing image pairs...';
                } else if (newWidth < 90) {
                    progressText.textContent = 'Calculating speeds...';
                } else {
                    progressText.textContent = 'Finalizing results...';
                }
            }
        }

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const title = section.previousElementSibling;
            
            if (section.classList.contains('collapsed')) {
                // Expand
                section.classList.remove('collapsed');
                title.classList.remove('collapsed');
            } else {
                // Collapse
                section.classList.add('collapsed');
                title.classList.add('collapsed');
            }
        }

        function displayAlgorithmComparison(results) {
            const container = document.getElementById('algorithmComparisonContainer');
            
            let html = '<div class="algorithm-comparison-results">';
            html += '<div class="comparison-header">';
            html += '<h4>🔬 Algorithm Comparison Results</h4>';
            html += `<div class="algorithm-stat-value">${results.total_images} images processed</div>`;
            html += '</div>';
            
            // Find the best algorithm
            let bestAlgorithm = null;
            let bestAccuracy = Infinity;
            
            for (const [key, result] of Object.entries(results.results)) {
                if (result.success && result.accuracy < bestAccuracy) {
                    bestAccuracy = result.accuracy;
                    bestAlgorithm = key;
                }
            }
            
            // Display each algorithm result
            for (const [key, result] of Object.entries(results.results)) {
                if (result.success) {
                    const accuracyStatus = result.accuracy < 0.1 ? 'Excellent' : 
                                         result.accuracy < 0.3 ? 'Good' : 
                                         result.accuracy < 0.5 ? 'Moderate' : 'Poor';
                    
                    const accuracyColor = result.accuracy < 0.1 ? '#4caf50' : 
                                        result.accuracy < 0.3 ? '#8bc34a' : 
                                        result.accuracy < 0.5 ? '#ff9800' : '#f44336';
                    
                    const isWinner = key === bestAlgorithm;
                    
                    html += '<div class="algorithm-card">';
                    html += '<div class="algorithm-header">';
                    html += `<div class="algorithm-name">${result.method}</div>`;
                    if (isWinner) {
                        html += '<div class="winner-badge">🏆 Winner</div>';
                    }
                    html += '</div>';
                    html += `<div class="algorithm-description">${result.description}</div>`;
                    
                    html += '<div class="algorithm-stats">';
                    html += '<div class="algorithm-stat">';
                    html += '<div class="algorithm-stat-label">Average Speed</div>';
                    html += `<div class="algorithm-stat-value">${result.average_speed.toFixed(4)} km/s</div>`;
                    html += '</div>';
                    
                    html += '<div class="algorithm-stat">';
                    html += '<div class="algorithm-stat-label">Accuracy</div>';
                    html += `<div class="algorithm-stat-value" style="color: ${accuracyColor};">${result.accuracy.toFixed(4)} km/s</div>`;
                    html += '</div>';
                    
                    html += '<div class="algorithm-stat">';
                    html += '<div class="algorithm-stat-label">Success Rate</div>';
                    html += `<div class="algorithm-stat-value">${result.successful_pairs}/${result.successful_pairs + result.failed_pairs}</div>`;
                    html += '</div>';
                    html += '</div>';
                    html += '</div>';
                } else {
                    html += '<div class="algorithm-card">';
                    html += '<div class="algorithm-header">';
                    html += `<div class="algorithm-name">${result.method}</div>`;
                    html += '<div class="winner-badge" style="background: #f44336;">❌ Failed</div>';
                    html += '</div>';
                    html += `<div class="algorithm-description">Error: ${result.error}</div>`;
                    html += '</div>';
                }
            }
            
            // Add comparison summary
            html += '<div class="comparison-summary">';
            html += '<h5>📊 Comparison Summary</h5>';
            html += '<p><strong>Target ISS Speed:</strong> 7.66 km/s</p>';
            if (bestAlgorithm) {
                const bestResult = results.results[bestAlgorithm];
                html += `<p><strong>Best Algorithm:</strong> ${bestResult.method} (${bestResult.accuracy.toFixed(4)} km/s difference)</p>`;
            }
            html += '<p><strong>Note:</strong> Lower accuracy values indicate better performance (closer to target speed)</p>';
            html += '</div>';
            
            html += '</div>';
            
            container.innerHTML = html;
        }

        function displayStatistics(stats) {
            const container = document.getElementById('statisticsContainer');
            
            // Debug: Log the actual statistics being displayed
            console.log('🔍 Frontend Section 3 Statistics Debug:');
            console.log('🔍   Mean:', stats.mean);
            console.log('🔍   Median:', stats.median);
            console.log('🔍   Mode:', stats.mode);
            console.log('🔍   Count:', stats.count);
            console.log('🔍   Full stats object:', stats);
            console.log('🔍   DEBUG: About to display statistics with count:', stats.count);
            
            // Check if stats object exists and has required properties
            if (!stats) {
                container.innerHTML = '<div class="error">No statistics data available</div>';
                return;
            }
            
            // GPS speed statistics removed - not allowed to use GPS location data
            
            let matchModeHtml = '';
            if (stats.match_mode !== undefined && stats.match_mode !== null) {
                matchModeHtml = `
                    <div class="stat-card">
                        <div class="stat-value">${stats.match_mode.toFixed(1)}</div>
                        <div class="stat-label">Match Mode Speed (km/s)</div>
                        <div class="stat-description"><strong>What it shows:</strong> The most frequently occurring speed value from all individual keypoint matches<br>
                            <strong>Method:</strong> Uses Counter to find the most common speed value (rounded to 1 decimal place)<br>
                            <strong>Logic:</strong> Counts all individual match speeds and identifies the value that appears most often<br>
                            <strong>Example:</strong> If speeds are [6.1, 6.1, 6.2, 6.1, 6.3], the mode is 6.1 km/s<br>
                            <strong>Purpose:</strong> Shows the typical speed of individual keypoint matches (not pairs)</div>
                    </div>
                `;
            }
            
            // Helper function to safely format numbers
            function safeFormat(value, decimals = 2) {
                if (value === undefined || value === null || isNaN(value)) {
                    return 'N/A';
                }
                return value.toFixed(decimals);
            }
            
            container.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${safeFormat(stats.mean, 2)}</div>
                        <div class="stat-label">Mean Speed (km/s)</div>
                        <div class="stat-description"><strong>What it shows:</strong> The arithmetic average of all individual keypoint match speeds<br>
                            <strong>Method:</strong> Uses sum of all speeds divided by total number of matches<br>
                            <strong>Logic:</strong> Calculates the central tendency of all individual match speeds<br>
                            <strong>Example:</strong> If speeds are [6.0, 6.5, 7.0], the mean is 6.5 km/s<br>
                            <strong>Purpose:</strong> Provides the overall average speed across all keypoint matches</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${safeFormat(stats.median, 2)}</div>
                        <div class="stat-label">Median Speed (km/s)</div>
                        <div class="stat-description"><strong>What it shows:</strong> The middle value when all individual match speeds are sorted<br>
                            <strong>Method:</strong> Sorts all speeds and selects the middle value (or average of two middle values)<br>
                            <strong>Logic:</strong> Divides the sorted speed list in half to find the central value<br>
                            <strong>Example:</strong> If speeds are [6.0, 6.5, 7.0, 7.5, 8.0], the median is 7.0 km/s<br>
                            <strong>Purpose:</strong> Shows the typical speed value, less affected by extreme outliers than the mean</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${safeFormat(stats.pair_mode, 1)}</div>
                        <div class="stat-label">Mode Speed (km/s)</div>
                        <div class="stat-description"><strong>What it shows:</strong> The most frequently occurring average speed from all image pairs<br>
                            <strong>Method:</strong> Calculates average speed per pair, then finds most common pair average<br>
                            <strong>Logic:</strong> Groups matches by pair, averages each pair's speeds, then finds most common average<br>
                            <strong>Example:</strong> If pair averages are [6.1, 6.1, 6.2, 6.1], the pair mode is 6.1 km/s<br>
                            <strong>Purpose:</strong> Shows the typical speed of image pairs (one value per pair, not per match)</div>
                    </div>
                    ${matchModeHtml}
                    <div class="stat-card">
                        <div class="stat-value">${stats.match_count || 'N/A'}</div>
                        <div class="stat-label">Total Matches</div>
                        <div class="stat-description"><strong>What it shows:</strong> Total count of individual keypoint matches across all image pairs<br>
                            <strong>Method:</strong> Counts all successful feature matches between consecutive images<br>
                            <strong>Logic:</strong> Sums up all keypoint correspondences found by the feature detection algorithm<br>
                            <strong>Example:</strong> If 3 image pairs have 100, 150, 200 matches respectively, total is 450 matches<br>
                            <strong>Purpose:</strong> Indicates the quality and quantity of feature detection results</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.count || 'N/A'}</div>
                        <div class="stat-label">Total Pairs</div>
                        <div class="stat-description"><strong>What it shows:</strong> Total count of consecutive image pairs used for speed calculation<br>
                            <strong>Method:</strong> Counts the number of sequential image pairs (N images = N-1 pairs)<br>
                            <strong>Logic:</strong> Each pair represents one speed measurement between two consecutive images<br>
                            <strong>Example:</strong> If 4 images are loaded, there are 3 pairs: (1→2), (2→3), (3→4)<br>
                            <strong>Purpose:</strong> Shows how many speed measurements were calculated from the image sequence</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${safeFormat(stats.std_dev, 2)}</div>
                        <div class="stat-label">Standard Deviation</div>
                        <div class="stat-description"><strong>What it shows:</strong> Statistical measure of how spread out the individual match speeds are<br>
                            <strong>Method:</strong> Uses standard deviation formula: √(Σ(x-μ)²/n) where μ is the mean<br>
                            <strong>Logic:</strong> Calculates the average distance of each speed from the mean speed<br>
                            <strong>Example:</strong> If speeds are [6.0, 6.5, 7.0] with mean 6.5, std dev shows how much they vary<br>
                            <strong>Purpose:</strong> Indicates the consistency of speed measurements (lower = more consistent)</div>
                    </div>
                </div>
            `;
        }

        function updateLegend() {
            const legendContainer = document.getElementById('legendContainer');
            const legendContent = document.getElementById('legendContent');
            const enableCloudiness = document.getElementById('enableCloudiness').checked;
            const enableMLClassification = document.getElementById('enableMLClassification').checked;
            
            console.log('🔍 Updating legend - Cloudiness:', enableCloudiness, 'ML:', enableMLClassification);
            
            if (enableCloudiness) {
                legendContainer.style.display = 'block';
                legendContent.innerHTML = `
                    <div class="legend-item">
                        <span class="legend-color" style="background-color: green;"></span>
                        <span class="legend-text">Clear</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background-color: orange;"></span>
                        <span class="legend-text">Partly Cloudy</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background-color: red;"></span>
                        <span class="legend-text">Mostly Cloudy</span>
                    </div>
                `;
                console.log('🔍 Legend set to cloudiness categories');
            } else if (enableMLClassification) {
                legendContainer.style.display = 'block';
                legendContent.innerHTML = `
                    <div class="legend-item">
                        <span class="legend-color" style="background-color: green;"></span>
                        <span class="legend-text">Good</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background-color: red;"></span>
                        <span class="legend-text">Not_Good</span>
                    </div>
                `;
                console.log('🔍 Legend set to ML classification categories');
            } else {
                // Show default legend for pair analysis
                legendContainer.style.display = 'block';
                legendContent.innerHTML = `
                    <div class="legend-item">
                        <span class="legend-color" style="background-color: #1f77b4;"></span>
                        <span class="legend-text">Mean Speed</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background-color: #ff7f0e;"></span>
                        <span class="legend-text">Median Speed</span>
                    </div>
                `;
                console.log('🔍 Legend set to default pair analysis');
            }
        }

        async function refreshData() {
            console.log('🔄 Refresh button clicked - starting refreshData()');
            
            // Check if button is disabled
            const refreshBtn = document.getElementById('refreshBtn');
            if (refreshBtn && refreshBtn.disabled) {
                console.log('❌ Refresh button is disabled - cannot proceed');
                showMessage('Please load data first before applying filters', 'error');
                return;
            }
            
            // Log the refresh action with current filter states
            const currentFilters = {
                enableCustomGSD: document.getElementById('enableCustomGSD')?.checked || false,
                customGSD: document.getElementById('customGSD')?.value || '12648',
                enableCloudiness: document.getElementById('enableCloudiness')?.checked || false,
                clearBrightnessMin: document.getElementById('clearBrightnessMin')?.value || '120',
                clearContrastMin: document.getElementById('clearContrastMin')?.value || '50',
                cloudyBrightnessMax: document.getElementById('cloudyBrightnessMax')?.value || '60',
                cloudyContrastMax: document.getElementById('cloudyContrastMax')?.value || '40',
                enableKeypointPercentile: document.getElementById('enableKeypointPercentile')?.checked || false,
                keypointPercentileBottom: document.getElementById('keypointPercentileBottom')?.value || '5',
                keypointPercentileTop: document.getElementById('keypointPercentileTop')?.value || '5',
                enablePercentile: document.getElementById('enablePercentile')?.checked || false,
                pairPercentile: document.getElementById('pairPercentile')?.value || '10',
                enableStdDev: document.getElementById('enableStdDev')?.checked || false,
                stdDevMultiplier: document.getElementById('stdDevMultiplier')?.value || '2.0'
            };
            
            logAction('REFRESH_DATA', currentFilters);
            
            // Check if we have any data to filter
            try {
                const statsResponse = await fetch('/api/statistics');
                const stats = await statsResponse.json();
                if (!stats || stats.total_matches === 0) {
                    console.log('❌ No data available to filter');
                    showMessage('No data available to filter. Please load data first.', 'error');
                    return;
                }
                console.log('✅ Data available for filtering:', stats.total_matches, 'matches');
            } catch (error) {
                console.log('❌ Error checking for data:', error);
                showMessage('Error checking for data. Please load data first.', 'error');
                return;
            }
            
            // Remaining filters
            const enableKeypointPercentile = document.getElementById('enableKeypointPercentile').checked;
            const keypointPercentileBottom = parseFloat(document.getElementById('keypointPercentileBottom').value);
            const keypointPercentileTop = parseFloat(document.getElementById('keypointPercentileTop').value);
            
            const enablePercentile = document.getElementById('enablePercentile').checked;
            const pairPercentile = parseFloat(document.getElementById('pairPercentile').value);
            
            const enableStdDev = document.getElementById('enableStdDev').checked;
            const stdDevMultiplier = parseFloat(document.getElementById('stdDevMultiplier').value);
            
            const enableCloudiness = document.getElementById('enableCloudiness').checked;
            const includePartlyCloudy = document.getElementById('includePartlyCloudy').checked;
            const includeMostlyCloudy = document.getElementById('includeMostlyCloudy').checked;
            
            const clearBrightnessMin = parseFloat(document.getElementById('clearBrightnessMin').value);
            const clearContrastMin = parseFloat(document.getElementById('clearContrastMin').value);
            const cloudyBrightnessMax = parseFloat(document.getElementById('cloudyBrightnessMax').value);
            const cloudyContrastMax = parseFloat(document.getElementById('cloudyContrastMax').value);
            
            const enableMLClassification = document.getElementById('enableMLClassification').checked;
            const includeGood = document.getElementById('includeGood').checked;
            const includeNotGood = document.getElementById('includeNotGood').checked;
            
            // GSD Configuration
            const enableCustomGSD = document.getElementById('enableCustomGSD').checked;
            const customGSD = parseFloat(document.getElementById('customGSD').value) || 12648;
            
            // Only include filters that are actually enabled
            const filters = {};
            
            // Advanced filters - only include if enabled
            if (enableKeypointPercentile) {
                filters.enable_keypoint_percentile = true;
                filters.keypoint_percentile_bottom = keypointPercentileBottom;
                filters.keypoint_percentile_top = keypointPercentileTop;
            }
            
            if (enablePercentile) {
                filters.enable_percentile = true;
                filters.pair_percentile = pairPercentile;
            }
            
            if (enableStdDev) {
                filters.enable_std_dev = true;
                filters.std_dev_multiplier = stdDevMultiplier;
            }
            
            if (enableCloudiness) {
                filters.enable_cloudiness = true;
                filters.include_partly_cloudy = includePartlyCloudy;
                filters.include_mostly_cloudy = includeMostlyCloudy;
                filters.clear_brightness_min = clearBrightnessMin;
                filters.clear_contrast_min = clearContrastMin;
                filters.cloudy_brightness_max = cloudyBrightnessMax;
                filters.cloudy_contrast_max = cloudyContrastMax;
            }
            
            if (enableMLClassification) {
                filters.enable_ml_classification = true;
                filters.include_good = includeGood;
                filters.include_not_good = includeNotGood;
            }
            
            if (enableCustomGSD) {
                filters.enable_custom_gsd = true;
                filters.custom_gsd = customGSD;
            }

            try {
                console.log('📤 Sending filters to /api/apply-filters:', filters);
                const response = await fetch('/api/apply-filters', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(filters)
                });

                console.log('📥 Response status:', response.status);
                const result = await response.json();
                console.log('📥 Response data:', result);

                if (result.success) {
                    console.log('✅ Filters applied successfully');
                    console.log(`📊 Filter results: ${result.filtered_count}/${result.original_count} matches remaining`);
                    
                    displayStatistics(result.statistics);
                    showMessage(`Applied filters: ${result.filtered_count}/${result.original_count} matches remaining`, 'success');
                    
                    // Check if we have any data left after filtering
                    if (result.filtered_count === 0) {
                        console.log('⚠️ No data remaining after filtering - graph will be empty');
                        showMessage('Warning: No data matches your filter criteria. Graph will be empty.', 'error');
                    }
                    
                    // Update plots automatically
                    console.log('🔄 Updating plots with filtered data...');
                    updatePlots(result.statistics);
                    
                    // Update legend
                    updateLegend();
                } else {
                    console.log('❌ Filter application failed:', result.error);
                    showMessage('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('Error: ' + error.message, 'error');
            }
        }

        function resetAllStates() {
            // Clear all data
            currentData = null;
            filteredData = null;
            plotData = null;
            
            // Clear statistics
            document.getElementById('statisticsContainer').innerHTML = '<div class="loading">Click "Load Data" to see statistics</div>';
            
            // Clear graphs
            Plotly.purge('speedPlot');
            Plotly.purge('pairPlot');
            
            // Reset ALL filter checkboxes to unchecked state (with null checks)
            const enableKeypointPercentile = document.getElementById('enableKeypointPercentile');
            if (enableKeypointPercentile) enableKeypointPercentile.checked = false;
            
            const enablePercentile = document.getElementById('enablePercentile');
            if (enablePercentile) enablePercentile.checked = false;
            
            const enableStdDev = document.getElementById('enableStdDev');
            if (enableStdDev) enableStdDev.checked = false;
            
            const enableCloudiness = document.getElementById('enableCloudiness');
            if (enableCloudiness) enableCloudiness.checked = false;  // Disable cloudiness by default
            
            const includePartlyCloudy = document.getElementById('includePartlyCloudy');
            if (includePartlyCloudy) includePartlyCloudy.checked = true;
            
            const includeMostlyCloudy = document.getElementById('includeMostlyCloudy');
            if (includeMostlyCloudy) includeMostlyCloudy.checked = true;
            
            const enableMLClassification = document.getElementById('enableMLClassification');
            if (enableMLClassification) enableMLClassification.checked = false;
            
            const includeGood = document.getElementById('includeGood');
            if (includeGood) includeGood.checked = true;
            
            const includeNotGood = document.getElementById('includeNotGood');
            if (includeNotGood) includeNotGood.checked = true;
            
            // Force UI refresh by triggering change events (with null checks)
            if (includePartlyCloudy) includePartlyCloudy.dispatchEvent(new Event('change'));
            if (includeMostlyCloudy) includeMostlyCloudy.dispatchEvent(new Event('change'));
            if (includeGood) includeGood.dispatchEvent(new Event('change'));
            if (includeNotGood) includeNotGood.dispatchEvent(new Event('change'));
            
            // Debug: Log the state after reset (with null checks)
            console.log('🔄 After resetAllStates:');
            if (enableCloudiness) console.log('  enableCloudiness:', enableCloudiness.checked);
            if (includePartlyCloudy) console.log('  includePartlyCloudy:', includePartlyCloudy.checked);
            if (includeMostlyCloudy) console.log('  includeMostlyCloudy:', includeMostlyCloudy.checked);
            
            // Hide ALL filter parameter sections (with null checks)
            const keypointParam = document.getElementById('keypointPercentileParam');
            if (keypointParam) keypointParam.style.display = 'none';
            
            const percentileParam = document.getElementById('percentileParam');
            if (percentileParam) percentileParam.style.display = 'none';
            
            const stdDevParam = document.getElementById('stdDevParam');
            if (stdDevParam) stdDevParam.style.display = 'none';
            
            const cloudinessParams = document.getElementById('cloudinessParams');
            if (cloudinessParams) cloudinessParams.style.display = 'none';  // Hide cloudiness params by default
            
            const cloudinessParams2 = document.getElementById('cloudinessParams2');
            if (cloudinessParams2) cloudinessParams2.style.display = 'none';  // Hide cloudiness params by default
            
            const mlParams = document.getElementById('mlClassificationParams');
            if (mlParams) mlParams.style.display = 'none';
            
            // Reset filter values to defaults
            resetFilters();
            
            // Disable refresh button (with null check)
            const refreshBtn = document.getElementById('refreshBtn');
            if (refreshBtn) refreshBtn.disabled = true;
            
            // Clear any status messages
            const statusElements = document.querySelectorAll('.success, .error, .info');
            statusElements.forEach(el => el.remove());
            
            // Show reset message
            showMessage('State reset - ready for fresh data load', 'info');
            
            // Small delay to ensure UI updates
            setTimeout(() => {
                console.log('🔄 Final UI state check:');
                console.log('  includePartlyCloudy visually checked:', document.getElementById('includePartlyCloudy').checked);
                console.log('  includeMostlyCloudy visually checked:', document.getElementById('includeMostlyCloudy').checked);
            }, 100);
        }

        function resetFilters() {
            // Reset filter values to defaults (checkboxes are reset in resetAllStates)
            const keypointPercentileBottom = document.getElementById('keypointPercentileBottom');
            if (keypointPercentileBottom) {
                keypointPercentileBottom.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('keypointPercentileBottomValue');
                    if (valueDisplay) valueDisplay.textContent = this.value + '%';
                });
            }

            const keypointPercentileTop = document.getElementById('keypointPercentileTop');
            if (keypointPercentileTop) {
                keypointPercentileTop.addEventListener('input', function() {
                    const valueDisplay = document.getElementById('keypointPercentileTopValue');
                    if (valueDisplay) valueDisplay.textContent = this.value + '%';
                });
            }
            
            const pairPercentile = document.getElementById('pairPercentile');
            if (pairPercentile) pairPercentile.value = 30;
            
            const stdDevMultiplier = document.getElementById('stdDevMultiplier');
            if (stdDevMultiplier) stdDevMultiplier.value = 2.0;
            
            const clearBrightnessMin = document.getElementById('clearBrightnessMin');
            if (clearBrightnessMin) clearBrightnessMin.value = 120;
            
            const clearContrastMin = document.getElementById('clearContrastMin');
            if (clearContrastMin) clearContrastMin.value = 50;
            
            const cloudyBrightnessMax = document.getElementById('cloudyBrightnessMax');
            if (cloudyBrightnessMax) cloudyBrightnessMax.value = 60;
            
            const cloudyContrastMax = document.getElementById('cloudyContrastMax');
            if (cloudyContrastMax) cloudyContrastMax.value = 40;
            
            // Reset GSD Configuration
            const customGSD = document.getElementById('customGSD');
            if (customGSD) customGSD.value = 12648;
            
            // Note: RANSAC/Homography controls are in Section 2 (Algorithm Configuration)
            // and should NOT be reset here as they are part of the processing parameters

            // Note: Parameter sections are hidden in resetAllStates()

            // Update value displays (with null checks)
            const keypointPercentileBottomValue = document.getElementById('keypointPercentileBottomValue');
            if (keypointPercentileBottomValue) keypointPercentileBottomValue.textContent = '5%';
            
            const keypointPercentileTopValue = document.getElementById('keypointPercentileTopValue');
            if (keypointPercentileTopValue) keypointPercentileTopValue.textContent = '5%';
            if (keypointPercentileValue) keypointPercentileValue.textContent = '5%';
            
            const pairPercentileValue = document.getElementById('pairPercentileValue');
            const pairPercentileInput = document.getElementById('pairPercentile');
            if (pairPercentileValue && pairPercentileInput) {
                pairPercentileValue.textContent = pairPercentileInput.value + ' matches';
            }
            
            const stdDevMultiplierValue = document.getElementById('stdDevMultiplierValue');
            if (stdDevMultiplierValue) stdDevMultiplierValue.textContent = '2.0σ';
            
            const clearBrightnessMinValue = document.getElementById('clearBrightnessMinValue');
            if (clearBrightnessMinValue) clearBrightnessMinValue.textContent = '120';
            
            const clearContrastMinValue = document.getElementById('clearContrastMinValue');
            if (clearContrastMinValue) clearContrastMinValue.textContent = '50';
            
            const cloudyBrightnessMaxValue = document.getElementById('cloudyBrightnessMaxValue');
            if (cloudyBrightnessMaxValue) cloudyBrightnessMaxValue.textContent = '60';
            
            const cloudyContrastMaxValue = document.getElementById('cloudyContrastMaxValue');
            if (cloudyContrastMaxValue) cloudyContrastMaxValue.textContent = '40';
            
            const customGSDValue = document.getElementById('customGSDValue');
            if (customGSDValue) customGSDValue.textContent = '12648 cm/pixel';
            // Note: RANSAC/Homography value displays are in Section 2, not Section 4 filters
        }

        let plotData = null;
        
        // Action tracking for issue replication
        let actionLog = [];
        let sessionStartTime = new Date().toISOString();
        
        function logAction(action, details = {}) {
            const timestamp = new Date().toISOString();
            const logEntry = {
                timestamp: timestamp,
                action: action,
                details: details,
                url: window.location.href,
                userAgent: navigator.userAgent
            };
            actionLog.push(logEntry);
            
            // Console log with emoji for easy identification
            console.log(`🎬 ACTION: ${action}`, details);
            
            // Keep only last 100 actions to prevent memory issues
            if (actionLog.length > 100) {
                actionLog = actionLog.slice(-100);
            }
        }
        
        function exportActionLog() {
            const logSummary = {
                sessionStart: sessionStartTime,
                sessionEnd: new Date().toISOString(),
                totalActions: actionLog.length,
                actions: actionLog,
                currentState: {
                    folder: document.getElementById('folderSelect')?.value || 'none',
                    startIdx: document.getElementById('startIdx')?.value || '0',
                    endIdx: document.getElementById('endIdx')?.value || '0',
                    algorithm: document.getElementById('algorithm')?.value || 'ORB',
                    useFlann: document.getElementById('useFlann')?.checked || false,
                    useRansacHomography: document.getElementById('useRansacHomography')?.checked || false,
                    contrastEnhancement: document.getElementById('contrastEnhancement')?.value || 'none',
                    maxFeatures: document.getElementById('maxFeatures')?.value || '1000',
                    // Add all filter states
                    enableCustomGSD: document.getElementById('enableCustomGSD')?.checked || false,
                    customGSD: document.getElementById('customGSD')?.value || '12648',
                    enableCloudiness: document.getElementById('enableCloudiness')?.checked || false,
                    clearBrightnessMin: document.getElementById('clearBrightnessMin')?.value || '120',
                    clearContrastMin: document.getElementById('clearContrastMin')?.value || '50',
                    cloudyBrightnessMax: document.getElementById('cloudyBrightnessMax')?.value || '60',
                    cloudyContrastMax: document.getElementById('cloudyContrastMax')?.value || '40'
                },
                // Include current statistics from Section 3
                currentStatistics: getCurrentStatistics(),
                // Include current plot data for Sections 4&5
                currentPlotData: plotData
            };
            
            console.log('📋 ACTION LOG EXPORT:', logSummary);
            return logSummary;
        }
        
        function getCurrentStatistics() {
            // Extract current statistics from Section 3 display
            const statsContainer = document.querySelector('.stats-container');
            if (!statsContainer) return null;
            
            const stats = {};
            const statCards = statsContainer.querySelectorAll('.stat-card');
            
            statCards.forEach(card => {
                const label = card.querySelector('.stat-label')?.textContent?.trim();
                const value = card.querySelector('.stat-value')?.textContent?.trim();
                if (label && value) {
                    // Convert label to key format
                    const key = label.toLowerCase()
                        .replace(/[^a-z0-9\s]/g, '')
                        .replace(/\s+/g, '_')
                        .replace(/km\/s/g, 'km_s');
                    stats[key] = value;
                }
            });
            
            return stats;
        }
        
        // Make export function globally available
        window.exportActionLog = exportActionLog;

        function showEmptyPlots() {
            // Show empty plots with helpful messages when no data is available
            const speedPlotContainer = document.getElementById('speedPlot');
            const pairPlotContainer = document.getElementById('pairPlot');
            
            if (speedPlotContainer) {
                speedPlotContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <h3>No Data Available</h3>
                        <p>Process some image data to see the speed distribution histogram.</p>
                        <p>Use the controls above to select a photo folder and process image pairs.</p>
                    </div>
                `;
            }
            
            if (pairPlotContainer) {
                pairPlotContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <h3>No Data Available</h3>
                        <p>Process some image data to see the pair analysis graph.</p>
                        <p>Use the controls above to select a photo folder and process image pairs.</p>
                    </div>
                `;
            }
        }

        async function updatePlots(stats) {
            // Load plot data from backend
            try {
                console.log('🔄 Loading plot data...');
                const response = await fetch('/api/plot-data');
                console.log('📥 Plot data response status:', response.status);
                plotData = await response.json();
                
                console.log('📊 Plot data received:', plotData);
                
                // Log plot data update
                logAction('PLOT_DATA_UPDATED', {
                    plotData: plotData,
                    timestamp: new Date().toISOString(),
                    dataSummary: {
                        pairsCount: plotData?.pairs?.pairs?.length || 0,
                        histogramCount: plotData?.histogram?.speeds?.length || 0,
                        boxplotCount: plotData?.boxplot?.speeds?.length || 0
                    }
                });
                
                console.log('📊 Plot data structure:', {
                    has_pairs: plotData && plotData.pairs ? 'yes' : 'no',
                    pairs_count: plotData && plotData.pairs && plotData.pairs.pairs ? plotData.pairs.pairs.length : 0,
                    has_histogram: plotData && plotData.histogram ? 'yes' : 'no',
                    histogram_count: plotData && plotData.histogram && plotData.histogram.speeds ? plotData.histogram.speeds.length : 0
                });
                
                if (plotData.error) {
                    if (plotData.error === 'No data processed') {
                        console.log('ℹ️ No data processed yet - this is normal when first loading the dashboard');
                        // Show empty plots instead of error
                        showEmptyPlots();
                        return;
                    } else {
                        console.error('Error loading plot data:', plotData.error);
                        return;
                    }
                }
                
                // Create plots using the same functions as original dashboard
                console.log('🎨 Creating plots...');
                createPlots();
                console.log('✅ Plots created successfully');
            } catch (error) {
                console.error('Error loading plot data:', error);
            }
        }

        function createPlots() {
            console.log('🎨 createPlots called with plotData:', plotData);
            
            try {
                if (!plotData) {
                    console.log('❌ No plotData available');
                    return;
                }
                
                
                // Check if pairs data exists and has required fields
                if (!plotData.pairs || !plotData.pairs.pairs || !plotData.pairs.means || !plotData.pairs.stds) {
                    console.error('❌ Missing required pairs data:', plotData.pairs);
                    return;
                }
                
                // Check if we have data
                const hasData = plotData.histogram && plotData.histogram.speeds && plotData.histogram.speeds.length > 0;
                console.log('📊 Has data:', hasData, 'Speed count:', plotData.histogram?.speeds?.length || 0);
                
                if (!hasData) {
                    console.log('❌ No data to plot');
                    return;
                }
            
            // Create histogram (same as original dashboard)
            const speeds = plotData.histogram.speeds;
            console.log('📊 Speeds array length:', speeds.length);
            
            // Debug: Log the histogram statistics being used
            console.log('🔍 Frontend Section 5 Histogram Debug:');
            console.log('🔍   Histogram Mean:', plotData.histogram.mean);
            console.log('🔍   Histogram Median:', plotData.histogram.median);
            console.log('🔍   Histogram Std:', plotData.histogram.std);
            
            // Check if speeds array is too large (could cause stack overflow)
            if (speeds.length > 10000) {
                console.log('⚠️ Large dataset detected, using sample for visualization');
                // Sample the data to prevent stack overflow
                const sampleSize = 1000;
                const step = Math.floor(speeds.length / sampleSize);
                const sampledSpeeds = speeds.filter((_, index) => index % step === 0);
                console.log('📊 Using sampled speeds:', sampledSpeeds.length);
            }
            
            // Use safer min/max calculation for large arrays
            let minSpeed, maxSpeed;
            if (speeds.length > 1000) {
                // For large arrays, use a more efficient approach
                minSpeed = speeds[0];
                maxSpeed = speeds[0];
                for (let i = 1; i < speeds.length; i++) {
                    if (speeds[i] < minSpeed) minSpeed = speeds[i];
                    if (speeds[i] > maxSpeed) maxSpeed = speeds[i];
                }
            } else {
                minSpeed = Math.min(...speeds);
                maxSpeed = Math.max(...speeds);
            }
            
            const speedRange = maxSpeed - minSpeed;
            const binSize = Math.max(0.1, speedRange / 30); // At least 0.1 km/s bins, max 30 bins
            
            // Use sampled data if available, otherwise use full data
            const plotSpeeds = speeds.length > 10000 ? 
                speeds.filter((_, index) => index % Math.floor(speeds.length / 1000) === 0) : 
                speeds;
            
            Plotly.newPlot('speedPlot', [{
                x: plotSpeeds,
                type: 'histogram',
                xbins: {
                    start: minSpeed - binSize/2,
                    end: maxSpeed + binSize/2,
                    size: binSize
                },
                marker: {color: 'skyblue', line: {color: 'black', width: 1}},
                name: 'Speed Distribution'
            }], {
                title: 'Speed Distribution of All Keypoints',
                xaxis: {
                    title: 'Speed (km/s)',
                    range: [minSpeed - speedRange * 0.05, maxSpeed + speedRange * 0.05]
                },
                yaxis: {title: 'Number of Keypoints'},
                shapes: [
                    {type: 'line', x0: plotData.histogram.mean, x1: plotData.histogram.mean, y0: 0, y1: 1, yref: 'paper', line: {color: 'red', width: 2, dash: 'dash'}},
                    {type: 'line', x0: plotData.histogram.median, x1: plotData.histogram.median, y0: 0, y1: 1, yref: 'paper', line: {color: 'blue', width: 2, dash: 'dot'}},
                    {type: 'line', x0: 7.66, x1: 7.66, y0: 0, y1: 1, yref: 'paper', line: {color: 'orange', width: 3}}
                ],
                annotations: [
                    {x: plotData.histogram.mean, y: 0.9, yref: 'paper', text: `Mean: ${plotData.histogram.mean.toFixed(3)} km/s`, showarrow: false, xanchor: 'left'},
                    {x: plotData.histogram.median, y: 0.85, yref: 'paper', text: `Median: ${plotData.histogram.median.toFixed(3)} km/s`, showarrow: false, xanchor: 'left'},
                    {x: 7.66, y: 0.8, yref: 'paper', text: 'Target: 7.66 km/s', showarrow: false, xanchor: 'left'}
                ]
            }, {responsive: true});
            
            // Create pairs plot (exactly like original dashboard)
            const colorGroups = {};
            
            // Group by color (exactly like original)
            console.log('📊 Pairs data structure:', {
                pairs: plotData.pairs.pairs?.length,
                means: plotData.pairs.means?.length,
                medians: plotData.pairs.medians?.length,
                stds: plotData.pairs.stds?.length,
                colors: plotData.pairs.colors?.length
            });
            
            for (let i = 0; i < plotData.pairs.pairs.length; i++) {
                const color = plotData.pairs.colors[i];
                if (!colorGroups[color]) {
                    colorGroups[color] = {x: [], y: [], y_median: [], error_y: [], customdata: []};
                }
                colorGroups[color].x.push(plotData.pairs.pairs[i]);
                colorGroups[color].y.push(plotData.pairs.means[i]);
                // Use median if available, otherwise fall back to mean
                const medianValue = (plotData.pairs.medians && plotData.pairs.medians.length > i && plotData.pairs.medians[i] !== undefined) 
                    ? plotData.pairs.medians[i] 
                    : plotData.pairs.means[i];
                colorGroups[color].y_median.push(medianValue);
                colorGroups[color].error_y.push(plotData.pairs.stds[i]);
                colorGroups[color].customdata.push(plotData.pairs.original_pairs ? plotData.pairs.original_pairs[i] : plotData.pairs.pairs[i]);
            }
            
            // Create traces for each color group (exactly like original)
            const pairTraces = [];
            const colorMap = {green: 'Clear', orange: 'Partly Cloudy', red: 'Mostly Cloudy', gray: 'Unknown'};
            
            Object.keys(colorGroups).forEach(color => {
                const group = colorGroups[color];
                if (group.x.length > 0) {
                    // Add mean trace
                    pairTraces.push({
                        x: group.x,
                        y: group.y,
                        error_y: {type: 'data', array: group.error_y},
                        mode: 'markers',
                        marker: {color: color, size: 10, symbol: 'circle'},
                        name: colorMap[color] || 'Unknown (Mean)',
                        customdata: group.customdata,
                        hovertemplate: 'Pair: %{customdata}<br>Mean Speed: %{y:.3f} km/s<br>Std: %{error_y.array[0]:.3f}<br>Click to view images<extra></extra>'
                    });
                    
                    // Add median trace (only if we have median data)
                    if (group.y_median && group.y_median.length > 0) {
                        pairTraces.push({
                            x: group.x,
                            y: group.y_median,
                            mode: 'markers',
                            marker: {color: color, size: 8, symbol: 'diamond'},
                            name: colorMap[color] + ' (Median)',
                            customdata: group.customdata,
                            hovertemplate: 'Pair: %{customdata}<br>Median Speed: %{y:.3f} km/s<br>Click to view images<extra></extra>',
                            showlegend: false  // Hide from legend to avoid clutter
                        });
                    }
                }
            });
            
            Plotly.newPlot('pairPlot', pairTraces, {
                title: 'Mean and Median Speed per Image Pair (Click any dot to view details)',
                xaxis: {title: 'Image Pair Number'},
                yaxis: {title: 'Speed (km/s)'},
                shapes: [
                    {type: 'line', x0: 0, x1: 1, xref: 'paper', y0: 7.66, y1: 7.66, line: {color: 'blue', width: 3}}
                ],
                annotations: [
                    {x: 0.5, y: 7.66, xref: 'paper', text: 'Target: 7.66 km/s', showarrow: false, yanchor: 'bottom'}
                ]
            });
            
            // Add click event to pairs plot (exactly like original)
            document.getElementById('pairPlot').on('plotly_click', function(data) {
                console.log('Plot click event:', data);
                const pairNum = data.points[0].customdata;
                console.log('Clicked pair number:', pairNum);
                showPairImages(pairNum);
            });
            
                console.log('✅ Both plots created successfully!');
                console.log('📊 Speed plot container:', document.getElementById('speedPlot'));
                console.log('📊 Pair plot container:', document.getElementById('pairPlot'));
            } catch (error) {
                console.error('❌ Error creating plots:', error);
            }
        }

        function showMessage(message, type) {
            const container = document.getElementById('statisticsContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = type;
            messageDiv.textContent = message;
            container.insertBefore(messageDiv, container.firstChild);
            
            // Remove message after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        async function showPairImages(pairNum) {
            console.log('showPairImages called with pairNum:', pairNum);
            try {
                const response = await fetch(`/api/pair/${pairNum}`);
                console.log('API response status:', response.status);
                const data = await response.json();
                console.log('API response data:', data);
                
                if (data.error) {
                    showMessage(data.error, 'error');
                    return;
                }
                
                document.getElementById('modalTitle').textContent = `Pair ${pairNum} Details`;
                
                const content = `
                    <div class="pair-info">
                        <h3>Pair Information</h3>
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">Average Speed:</span>
                                <span class="info-value">${data.avg_speed.toFixed(3)} km/s</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Standard Deviation:</span>
                                <span class="info-value">${data.std_speed.toFixed(3)} km/s</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Keypoints:</span>
                                <span class="info-value">${data.keypoint_count}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Time Difference:</span>
                                <span class="info-value">${data.time_diff} seconds</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Image Quality:</span>
                                <span class="info-value">${data.cloudiness}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Brightness:</span>
                                <span class="info-value">${data.brightness.toFixed(1)}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Contrast:</span>
                                <span class="info-value">${data.contrast.toFixed(1)}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Accuracy:</span>
                                <span class="info-value">${data.accuracy.toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="image-container">
                        <div class="image-item">
                            <h4>Image 1: ${data.image1}</h4>
                            <img src="data:image/jpeg;base64,${data.image1_data}" alt="Image 1">
                        </div>
                        <div class="image-item">
                            <h4>Image 2: ${data.image2}</h4>
                            <img src="data:image/jpeg;base64,${data.image2_data}" alt="Image 2">
                        </div>
                    </div>
                    
                    <div class="matches-section">
                        <h3>Keypoint Matches (${data.displayed_matches} of ${data.total_matches} shown)</h3>
                        <p>Lines connect matching keypoints between the two images. This shows how features moved between the images.</p>
                        <img src="data:image/jpeg;base64,${data.matches_data}" alt="Keypoint Matches" style="max-width: 100%; height: auto; border: 1px solid #dee2e6; border-radius: 4px;">
                    </div>
                `;
                
                document.getElementById('modalContent').innerHTML = content;
                document.getElementById('imageModal').style.display = 'block';
                console.log('Modal displayed for pair:', pairNum);
                
            } catch (error) {
                showMessage('Error loading pair images: ' + error.message, 'error');
            }
        }
        
        function closeModal() {
            document.getElementById('imageModal').style.display = 'none';
        }
        
        async function showCacheStatus() {
            try {
                const response = await fetch('/api/cache-status');
                const result = await response.json();
                
                if (result.success) {
                    let message = `📊 Cache Status:\n\nTotal cache files: ${result.total_files}\n\n`;
                    
                    if (result.cache_files.length > 0) {
                        result.cache_files.forEach(cache => {
                            message += `• ${cache.file}\n  Size: ${cache.size_mb} MB\n  Created: ${cache.created}\n\n`;
                        });
                    } else {
                        message += 'No cache files found.';
                    }
                    
                    alert(message);
                } else {
                    showMessage('Error getting cache status: ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('Error: ' + error.message, 'error');
            }
        }

        async function clearAllCache() {
            if (confirm('Are you sure you want to clear all cache files? This will remove all saved processing results.')) {
                try {
                    const response = await fetch('/api/clear-v2-cache', {
                        method: 'POST'
                    });
                    const result = await response.json();
                    
                    if (result.success) {
                        showMessage(result.message, 'success');
                    } else {
                        showMessage('Error clearing cache: ' + result.error, 'error');
                    }
                } catch (error) {
                    showMessage('Error: ' + error.message, 'error');
                }
            }
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('imageModal');
            if (event.target === modal) {
                closeModal();
            }
        }
    </script>
</body>
</html>

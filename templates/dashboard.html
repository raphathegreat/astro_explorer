<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISS Speed Analysis Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }
        .control-row {
            display: flex;
            align-items: center;
            margin: 15px 0;
            gap: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            font-weight: bold;
            color: #495057;
            min-width: 120px;
            text-align: right;
        }
        .control-group input[type="range"] {
            width: 150px;
            margin: 0 10px;
        }
        .control-group input[type="number"] {
            width: 80px;
            padding: 5px 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .control-group select {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            min-width: 200px;
        }
        .value-display {
            font-weight: bold;
            color: #007bff;
            min-width: 50px;
            text-align: center;
        }
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 5px;
        }
        .btn:hover {
            background: #0056b3;
        }
        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .btn-select {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px 0;
            min-width: 200px;
            text-align: left;
        }
        .btn-select:hover {
            background: #218838;
        }
        .gallery-content {
            max-width: 90vw;
            max-height: 90vh;
            width: 90vw;
            height: 90vh;
        }
        .gallery-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            padding: 20px;
            max-height: calc(90vh - 100px);
            overflow-y: auto;
        }
        .gallery-item {
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        .gallery-item:hover {
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .gallery-item.selected {
            border-color: #28a745;
            background-color: #d4edda;
        }
        .gallery-item img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 4px;
        }
        .gallery-item .image-name {
            margin-top: 8px;
            font-size: 12px;
            color: #495057;
            word-break: break-all;
        }
        .gallery-item .image-stats {
            margin-top: 5px;
            font-size: 11px;
            color: #6c757d;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            display: none;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .gps-status {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            background: #e8f5e8;
            color: #155724;
            border: 1px solid #c3e6cb;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .image-preview {
            margin-top: 10px;
            max-width: 150px;
            max-height: 100px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            overflow: hidden;
        }
        .image-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .reference-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        .reference-info h4 {
            margin: 0 0 10px 0;
            color: #495057;
        }
        .reference-info p {
            margin: 0;
            color: #6c757d;
            font-size: 0.9em;
            line-height: 1.4;
        }
        .plots {
            padding: 20px;
        }
        .plot-container {
            margin: 20px 0;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            overflow: hidden;
        }
        .plot-title {
            background: #e9ecef;
            padding: 10px 15px;
            margin: 0;
            font-size: 16px;
            font-weight: bold;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        .image-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .image-box {
            flex: 1;
            text-align: center;
        }
        .image-box img {
            max-width: 100%;
            height: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        .pair-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #dee2e6;
        }
        .info-label {
            font-weight: bold;
            color: #495057;
        }
        .info-value {
            color: #6c757d;
        }
        .keypoint-matches {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        .keypoint-matches h3 {
            margin: 0 0 10px 0;
            color: #495057;
        }
        .keypoint-matches p {
            margin: 0 0 15px 0;
            color: #6c757d;
            font-style: italic;
        }
        .speedometer-container {
            margin: 20px 0;
            display: flex;
            justify-content: space-around;
            gap: 15px;
        }
        .speedometer {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 200px;
        }
        .speedometer h3 {
            margin: 0 0 15px 0;
            font-size: 1.1em;
            font-weight: 300;
        }
        .count-display {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 8px;
        }
        .count-unit {
            font-size: 0.8em;
        }
        .mode-display {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 8px;
        }
        .mode-selector select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            font-size: 0.9em;
        }
        .speed-display {
            margin: 15px 0;
        }
        .speed-display span:first-child {
            font-size: 2.5em;
            font-weight: bold;
            display: block;
        }
        .speed-unit {
            font-size: 1.2em;
            opacity: 0.8;
        }
        .accuracy-display {
            margin: 15px 0;
        }
        .accuracy-display #currentAccuracy {
            font-size: 2em;
            font-weight: bold;
            display: block;
        }
        .accuracy-unit {
            font-size: 1em;
            opacity: 0.8;
        }
        .progress-container {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .progress-header h3 {
            margin: 0;
            color: #495057;
        }
        .progress-header span {
            font-weight: bold;
            color: #007bff;
            font-size: 1.1em;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        .progress-details {
            font-size: 0.9em;
            color: #6c757d;
            text-align: center;
        }
        
        /* New Filter Design Styles */
        .filter-row {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            cursor: move;
            transition: all 0.2s ease;
        }
        
        .filter-row:hover {
            background: #e9ecef;
            border-color: #007bff;
        }
        
        .filter-row.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }
        
        .filter-row.drag-over {
            border-color: #28a745;
            background: #d4edda;
        }
        
        .drag-handle {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
        }
        
        .drag-handle:active {
            cursor: grabbing;
        }
        
        .drag-handle::before {
            content: "⋮⋮";
            font-size: 12px;
            line-height: 1;
        }
        
        .filter-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .toggle-container {
            flex-shrink: 0;
        }
        
        .toggle {
            display: none;
        }
        
        .toggle-label {
            display: block;
            width: 50px;
            height: 25px;
            background: #ccc;
            border-radius: 25px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-label:before {
            content: '';
            position: absolute;
            width: 21px;
            height: 21px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        
        .toggle:checked + .toggle-label {
            background: #007bff;
        }
        
        .toggle:checked + .toggle-label:before {
            transform: translateX(25px);
        }
        
        .filter-content {
            flex: 1;
            min-width: 0;
        }
        
        .filter-content label {
            display: block;
            font-size: 0.9em;
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
        }
        
        .filter-description {
            flex: 1;
            font-size: 0.8em;
            color: #6c757d;
            font-style: italic;
            text-align: right;
            max-width: 200px;
        }
        
        .filter-parameter {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .filter-parameter label {
            font-size: 0.8em;
            color: #495057;
            font-weight: 500;
        }
        
        .filter-parameter input[type="number"] {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.8em;
        }
        
        .range-separator {
            margin: 0 10px;
            color: #6c757d;
            font-weight: 500;
        }
        
        .checkbox-container {
            display: flex;
            gap: 20px;
            margin-top: 8px;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.85em;
        }
        
        .checkbox-label input[type="checkbox"] {
            display: none;
        }
        
        .checkmark {
            width: 18px;
            height: 18px;
            border: 2px solid #ccc;
            border-radius: 3px;
            margin-right: 8px;
            position: relative;
            transition: all 0.3s;
        }
        
        .checkbox-label input[type="checkbox"]:checked + .checkmark {
            background: #007bff;
            border-color: #007bff;
        }
        
        .checkbox-label input[type="checkbox"]:checked + .checkmark:after {
            content: '';
            position: absolute;
            left: 5px;
            top: 2px;
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        .checkbox-label input[type="checkbox"]:disabled + .checkmark {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .slider-container input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .value-display {
            font-size: 0.85em;
            font-weight: 600;
            color: #007bff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 ISS Speed Analysis Dashboard</h1>
            <p>Interactive analysis of ISS speed from image pairs</p>
        </div>
        
        <div class="controls">
            <!-- Folder Selection Row -->
            <div class="control-row">
                <div class="control-group">
                    <label for="folderSelect">Photos Folder:</label>
                    <select id="folderSelect">
                        <option value="">Select a folder...</option>
                    </select>
                </div>
            </div>
            
            <!-- Sequence Range Filter (Always First) -->
            <div class="filter-row" data-filter-order="1">
                <div class="drag-handle" title="Drag to reorder (Sequence filter is always first)"></div>
                <div class="filter-control">
                    <div class="toggle-container">
                        <input type="checkbox" id="enableSequence" class="toggle" checked>
                        <label for="enableSequence" class="toggle-label"></label>
                    </div>
                    <div class="filter-content">
                        <label for="startPair">Image Sequence Range</label>
                        <div class="slider-container">
                            <input type="range" id="startPair" min="1" max="100" value="1" step="1">
                            <span class="value-display" id="startPairValue">1</span>
                            <span class="range-separator">to</span>
                            <input type="range" id="endPair" min="1" max="100" value="41" step="1">
                            <span class="value-display" id="endPairValue">41</span>
                        </div>
                    </div>
                    <div class="filter-description">
                        Analyze only keypoints from pairs within this range
                    </div>
                </div>
            </div>
            
            <!-- Speed Calculation Mode -->
            <div class="filter-row" data-filter-order="0">
                <div class="drag-handle" title="Speed calculation method"></div>
                <div class="filter-control">
                    <div class="filter-content">
                        <label for="speedMode">Speed Calculation Mode</label>
                        <div class="mode-selector">
                            <select id="speedMode">
                                <option value="gps_only">GPS-Only (Most Accurate)</option>
                                <option value="constant_gsd">Constant GSD (ESA Default)</option>
                                <option value="dynamic_gsd" selected>Dynamic GSD (GPS + Keypoints)</option>
                            </select>
                        </div>
                    </div>
                    <div class="filter-description">
                        Choose how to calculate ISS speed from the data
                    </div>
                </div>
            </div>
            
            <!-- GPS Consistency Filter -->
            <div class="filter-row" data-filter-order="1">
                <div class="drag-handle" title="Drag to reorder"></div>
                <div class="filter-control">
                    <div class="toggle-container">
                        <input type="checkbox" id="enableGpsConsistency" class="toggle">
                        <label for="enableGpsConsistency" class="toggle-label"></label>
                    </div>
                    <div class="filter-content">
                        <label for="gpsToleranceConstant">GPS Consistency Filter</label>
                        <div class="filter-parameter" id="gpsConsistencyParam" style="display: none;">
                            <label for="gpsToleranceConstant">Tolerance (km/s):</label>
                            <input type="number" id="gpsToleranceConstant" value="0.783" min="0" max="5" step="0.001" style="width: 80px;">
                        </div>
                    </div>
                    <div class="filter-description">
                        Remove keypoints with Constant GSD speeds outside GPS-only speed range (GPS data required)
                    </div>
                </div>
            </div>
            
            <!-- Keypoint Percentile Filter -->
            <div class="filter-row" data-filter-order="3">
                <div class="drag-handle" title="Drag to reorder"></div>
                <div class="filter-control">
                    <div class="toggle-container">
                        <input type="checkbox" id="enableKeypointPercentile" class="toggle">
                        <label for="enableKeypointPercentile" class="toggle-label"></label>
                    </div>
                    <div class="filter-content">
                        <label for="keypointPercentile">Keypoint Percentile Filter</label>
                        <div class="slider-container">
                            <input type="range" id="keypointPercentile" min="0" max="50" value="5" step="1" disabled>
                            <span class="value-display" id="keypointPercentileValue">5</span>
                        </div>
                    </div>
                    <div class="filter-description">
                        Remove bottom and top X% of keypoints by speed (outlier removal)
                    </div>
                </div>
            </div>
            
            <!-- Pair Percentile Filter -->
            <div class="filter-row" data-filter-order="4">
                <div class="drag-handle" title="Drag to reorder"></div>
                <div class="filter-control">
                    <div class="toggle-container">
                        <input type="checkbox" id="enablePercentile" class="toggle">
                        <label for="enablePercentile" class="toggle-label"></label>
                    </div>
                    <div class="filter-content">
                        <label for="pairPercentile">Pair Percentile Filter</label>
                        <div class="slider-container">
                            <input type="range" id="pairPercentile" min="0" max="50" value="30" step="5" disabled>
                            <span class="value-display" id="pairPercentileValue">30</span>
                        </div>
                    </div>
                    <div class="filter-description">
                        Remove bottom X% of pairs with fewest keypoints
                    </div>
                </div>
            </div>
            
            <!-- Standard Deviation Filter -->
            <div class="filter-row" data-filter-order="5">
                <div class="drag-handle" title="Drag to reorder"></div>
                <div class="filter-control">
                    <div class="toggle-container">
                        <input type="checkbox" id="enableStdDev" class="toggle">
                        <label for="enableStdDev" class="toggle-label"></label>
                    </div>
                    <div class="filter-content">
                        <label for="stdDevMultiplier">Standard Deviation Filter</label>
                        <div class="slider-container">
                            <input type="range" id="stdDevMultiplier" min="0" max="3" value="2" step="0.1" disabled>
                            <span class="value-display" id="stdDevMultiplierValue">2.0</span>
                        </div>
                    </div>
                    <div class="filter-description">
                        Remove outliers beyond X standard deviations from mean
                    </div>
                </div>
            </div>
            
            <!-- Cloudiness Filter -->
            <div class="filter-row" data-filter-order="6">
                <div class="drag-handle" title="Drag to reorder"></div>
                <div class="filter-control">
                    <div class="toggle-container">
                        <input type="checkbox" id="enableCloudiness" class="toggle">
                        <label for="enableCloudiness" class="toggle-label"></label>
                    </div>
                    <div class="filter-content">
                        <label>Cloudiness Filter</label>
                        <div class="checkbox-container">
                            <label class="checkbox-label">
                                <input type="checkbox" id="includePartlyCloudy" disabled>
                                <span class="checkmark"></span>
                                Include Partly Cloudy
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" id="includeMostlyCloudy" disabled>
                                <span class="checkmark"></span>
                                Include Mostly Cloudy
                            </label>
                        </div>
                    </div>
                    <div class="filter-description">
                        Select which cloudiness categories to include in analysis
                    </div>
                </div>
            </div>
            
            <!-- Image Classification Thresholds -->
            <div style="background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h4 style="margin: 0 0 15px 0; color: #495057;">Image Classification Thresholds</h4>
                <div style="display: flex; gap: 20px; margin-bottom: 10px;">
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #6c757d;">Clear Min Brightness:</label>
                        <input type="range" id="clearBrightnessMin" min="50" max="200" value="120" step="5" style="width: 100%;">
                        <span id="clearBrightnessMinValue" style="font-size: 0.8em; color: #495057;">120</span>
                    </div>
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #6c757d;">Clear Min Contrast:</label>
                        <input type="range" id="clearContrastMin" min="10" max="100" value="50" step="5" style="width: 100%;">
                        <span id="clearContrastMinValue" style="font-size: 0.8em; color: #495057;">50</span>
                    </div>
                </div>
                <div style="display: flex; gap: 20px;">
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #6c757d;">Cloudy Max Brightness:</label>
                        <input type="range" id="cloudyBrightnessMax" min="30" max="150" value="60" step="5" style="width: 100%;">
                        <span id="cloudyBrightnessMaxValue" style="font-size: 0.8em; color: #495057;">60</span>
                    </div>
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #6c757d;">Cloudy Max Contrast:</label>
                        <input type="range" id="cloudyContrastMax" min="5" max="80" value="15" step="5" style="width: 100%;">
                        <span id="cloudyContrastMaxValue" style="font-size: 0.8em; color: #495057;">15</span>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons Row -->
            <div class="control-row">
                <button class="btn" id="loadBtn" onclick="loadData()">Load Data</button>
                <button class="btn" id="defaultBtn" onclick="resetToDefaults()">Reset to Defaults</button>
                <button class="btn" id="clearCacheBtn" onclick="clearCache()" style="background-color: #ff6b6b;">Clear Cache</button>
            </div>
        </div>
        
        <div id="status" class="status"></div>
        <div id="gpsStatus" class="gps-status" style="display: none;">
            <span id="gpsIcon">🛰️</span>
            <span id="gpsText">GPS Enhanced Mode</span>
        </div>
        
        <div id="progressContainer" class="progress-container" style="display: none;">
            <div class="progress-header">
                <h3>Processing Data...</h3>
                <span id="progressText">0%</span>
            </div>
            <div class="progress-bar">
                <div id="progressBar" class="progress-fill"></div>
            </div>
            <div id="progressDetails" class="progress-details"></div>
        </div>
        
        <div class="speedometer-container">
            <div class="speedometer">
                <h3>Estimated ISS Speed</h3>
                <div class="speed-display">
                    <span id="currentSpeed">--</span>
                    <span class="speed-unit">km/s</span>
                </div>
                <div class="mode-display">
                    <span id="currentMode">--</span>
                </div>
            </div>
        </div>
        
        <div class="plots">
            <div class="plot-container">
                <h3 class="plot-title">Speed Distribution Histogram</h3>
                <div id="histogram"></div>
            </div>
            
            <div class="plot-container">
                <h3 class="plot-title">Average Speed per Image Pair (Click legend to toggle categories, click points to view images)</h3>
                <div id="pairs"></div>
            </div>
        </div>
    </div>
    
    <!-- Modal for displaying pair images -->
    <div id="imageModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2 id="modalTitle">Pair Details</h2>
            <div id="modalContent"></div>
        </div>
    </div>
    
    
    <script>
        let plotData = null;
        let updatingSequenceRange = false;
        let userModifiedEndPair = false;
        let draggedElement = null;
        
        function setupDragAndDrop() {
            const filterRows = document.querySelectorAll('.filter-row');
            
            filterRows.forEach(row => {
                // Skip the sequence filter (always first)
                if (row.dataset.filterOrder === '1') {
                    return;
                }
                
                row.draggable = true;
                
                row.addEventListener('dragstart', function(e) {
                    draggedElement = this;
                    this.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                row.addEventListener('dragend', function(e) {
                    this.classList.remove('dragging');
                    draggedElement = null;
                });
                
                row.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    this.classList.add('drag-over');
                });
                
                row.addEventListener('dragleave', function(e) {
                    this.classList.remove('drag-over');
                });
                
                row.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');
                    
                    if (draggedElement && draggedElement !== this) {
                        // Get the container
                        const container = this.parentNode;
                        
                        // Insert the dragged element before this element
                        container.insertBefore(draggedElement, this);
                        
                        // Update the filter order attributes and get the new order
                        const newOrder = updateFilterOrder();
                        
                        // Store the filter order for sending to backend
                        window.currentFilterOrder = newOrder;
                        
                        // Show status message
                        showStatus('Filter order updated', 'success');
                    }
                });
            });
        }
        
        function updateFilterOrder() {
            const filterRows = document.querySelectorAll('.filter-row');
            const filterOrder = [];
            filterRows.forEach((row, index) => {
                row.dataset.filterOrder = index + 1;
                // Get the filter type from the row
                const filterType = getFilterTypeFromRow(row);
                if (filterType) {
                    filterOrder.push(filterType);
                }
            });
            return filterOrder;
        }
        
        function getFilterTypeFromRow(row) {
            // Map filter rows to their types based on the enable checkbox IDs
            const enableCheckbox = row.querySelector('input[type="checkbox"]');
            if (!enableCheckbox) return null;
            
            const checkboxId = enableCheckbox.id;
            switch(checkboxId) {
                case 'enableSequence': return 'sequence';
                case 'enableKeypointPercentile': return 'keypoint_percentile';
                case 'enablePercentile': return 'percentile';
                case 'enableStdDev': return 'std_dev';
                case 'enableCloudiness': return 'cloudiness';
                case 'enableGpsConsistency': return 'gps_consistency';
                default: return null;
            }
        }
        
        // Load folders on page load
        window.onload = function() {
            loadFolders();
            setupSliders();
            setupDragAndDrop();
            
            // Initialize filter order
            window.currentFilterOrder = updateFilterOrder();
            
            // Enable sequence range filter by default
            document.getElementById('enableSequence').checked = true;
            toggleFilterControls('sequence', true);
            
            // Add folder change detection
            document.getElementById('folderSelect').addEventListener('change', function() {
                if (plotData) {
                    showStatus('Folder changed - data will be cleared when you load', 'info');
                }
            });
        };
        
        function setupSliders() {
            // Setup toggle switches
            const toggles = [
                'enablePercentile', 'enableStdDev', 'enableKeypointPercentile', 'enableSequence', 'enableCloudiness'
            ];
            
            toggles.forEach(toggleId => {
                const toggle = document.getElementById(toggleId);
                toggle.addEventListener('change', function() {
                    const filterType = toggleId.replace('enable', '').toLowerCase();
                    toggleFilterControls(filterType, this.checked);
                    
                    // Update button text to indicate refresh is needed
                    if (plotData) {
                        updateLoadButton('Refresh Data');
                    }
                });
            });
            
            // Setup slider event listeners
            const sliders = [
                'pairPercentile', 'stdDevMultiplier', 'keypointPercentile', 'startPair', 'endPair',
                'clearBrightnessMin', 'clearContrastMin', 'cloudyBrightnessMax', 'cloudyContrastMax'
            ];
            
            sliders.forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(sliderId + 'Value');
                
                slider.addEventListener('input', function() {
                    // Format display values appropriately
                    if (sliderId === 'minSpeed' || sliderId === 'maxSpeed' || sliderId === 'stdDevMultiplier') {
                        valueDisplay.textContent = parseFloat(this.value).toFixed(1);
                    } else {
                        valueDisplay.textContent = this.value;
                    }
                    
                    // Update button text to indicate refresh is needed
                    if (plotData) {
                        updateLoadButton('Refresh Data');
                    }
                });
            });
            
            // Special handling for pair range sliders
            const startPairSlider = document.getElementById('startPair');
            const endPairSlider = document.getElementById('endPair');
            
            startPairSlider.addEventListener('input', function() {
                const startValue = parseInt(this.value);
                const endValue = parseInt(endPairSlider.value);
                if (startValue > endValue) {
                    endPairSlider.value = startValue;
                    document.getElementById('endPairValue').textContent = startValue;
                }
            });
            
            endPairSlider.addEventListener('input', function() {
                const startValue = parseInt(startPairSlider.value);
                const endValue = parseInt(this.value);
                if (endValue < startValue) {
                    startPairSlider.value = endValue;
                    document.getElementById('startPairValue').textContent = endValue;
                }
                // Mark that user has manually modified the end pair slider
                userModifiedEndPair = true;
            });
            
            // Setup cloudiness checkboxes
            const cloudinessCheckboxes = ['includePartlyCloudy', 'includeMostlyCloudy'];
            cloudinessCheckboxes.forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                checkbox.addEventListener('change', function() {
                    if (plotData) {
                        updateLoadButton('Refresh Data');
                    }
                });
            });
        }
        
        function toggleFilterControls(filterType, enabled) {
            let controls = [];
            
            switch(filterType) {
                case 'percentile':
                    controls = ['pairPercentile'];
                    break;
                case 'stddev':
                    controls = ['stdDevMultiplier'];
                    break;
                case 'keypointpercentile':
                    controls = ['keypointPercentile'];
                    break;
                case 'sequence':
                    controls = ['startPair', 'endPair'];
                    break;
                case 'cloudiness':
                    controls = ['includePartlyCloudy', 'includeMostlyCloudy'];
                    break;
            }
            
            controls.forEach(controlId => {
                const control = document.getElementById(controlId);
                if (control) {
                    control.disabled = !enabled;
                }
            });
        }
        
        function updateLoadButton(text) {
            const loadBtn = document.getElementById('loadBtn');
            loadBtn.textContent = text;
        }
        
        function updateGpsConsistencyAvailability(gpsEnabled) {
            const gpsConsistencyToggle = document.getElementById('enableGpsConsistency');
            const gpsConsistencyRow = gpsConsistencyToggle.closest('.filter-row');
            const paramDiv = document.getElementById('gpsConsistencyParam');
            
            if (gpsEnabled) {
                gpsConsistencyRow.style.opacity = '1';
                gpsConsistencyToggle.disabled = false;
                gpsConsistencyRow.querySelector('.filter-description').textContent = 
                    'Remove keypoints with Constant GSD speeds outside GPS-only speed range';
                // Show parameter if toggle is checked
                if (gpsConsistencyToggle.checked) {
                    paramDiv.style.display = 'block';
                }
            } else {
                gpsConsistencyRow.style.opacity = '0.5';
                gpsConsistencyToggle.disabled = true;
                gpsConsistencyToggle.checked = false;
                paramDiv.style.display = 'none';
                gpsConsistencyRow.querySelector('.filter-description').textContent = 
                    'GPS data required - not available for this dataset';
            }
        }
        
        function updateSequenceRangeLimits(maxPairs) {
            if (updatingSequenceRange) {
                return;
            }
            
            updatingSequenceRange = true;
            
            const startPairSlider = document.getElementById('startPair');
            const endPairSlider = document.getElementById('endPair');
            
            if (!startPairSlider || !endPairSlider) {
                updatingSequenceRange = false;
                return;
            }
            
            // Update max values
            startPairSlider.max = maxPairs;
            endPairSlider.max = maxPairs;
            
            // Only set default value if it's the first time (no user interaction yet)
            if (!userModifiedEndPair && (endPairSlider.value === endPairSlider.max || endPairSlider.value > maxPairs)) {
                // Set to 41 or maxPairs, whichever is smaller
                const defaultEnd = Math.min(41, maxPairs);
                endPairSlider.value = defaultEnd;
                document.getElementById('endPairValue').textContent = defaultEnd;
            }
            
            // If user has set a value higher than the new max, cap it
            if (endPairSlider.value > maxPairs) {
                endPairSlider.value = maxPairs;
                document.getElementById('endPairValue').textContent = maxPairs;
            }
            
            // Sequence range limits updated
            
            updatingSequenceRange = false;
        }
        
        function resetToDefaults() {
            // Reset toggles - sequence range ON by default, others OFF
            const toggles = [
                'enablePercentile', 'enableStdDev', 'enableKeypointPercentile', 'enableCloudiness'
            ];
            
            toggles.forEach(toggleId => {
                const toggle = document.getElementById(toggleId);
                toggle.checked = false;
                const filterType = toggleId.replace('enable', '').toLowerCase();
                toggleFilterControls(filterType, false);
            });
            
            // Enable sequence range by default
            document.getElementById('enableSequence').checked = true;
            
            // Add speed mode change listener
            document.getElementById('speedMode').addEventListener('change', function() {
                updateSpeedometer();
                // Refresh data to update graphs with new speed mode
                if (plotData) {
                    refreshData();
                }
            });
            
            // GPS Consistency Filter toggle
            document.getElementById('enableGpsConsistency').addEventListener('change', function() {
                const paramDiv = document.getElementById('gpsConsistencyParam');
                if (this.checked) {
                    paramDiv.style.display = 'block';
                } else {
                    paramDiv.style.display = 'none';
                }
                
                // Refresh data if plotData exists
                if (plotData) {
                    refreshData();
                }
            });
            
            // GPS Tolerance Constant input
            document.getElementById('gpsToleranceConstant').addEventListener('input', function() {
                // Refresh data if plotData exists
                if (plotData) {
                    refreshData();
                }
            });
            toggleFilterControls('sequence', true);
            
            // Reset slider values to defaults
            document.getElementById('pairPercentile').value = 30;
            document.getElementById('pairPercentileValue').textContent = '30';
            
            document.getElementById('stdDevMultiplier').value = 2;
            document.getElementById('stdDevMultiplierValue').textContent = '2.0';
            
            document.getElementById('keypointPercentile').value = 5;
            document.getElementById('keypointPercentileValue').textContent = '5';
            
            document.getElementById('startPair').value = 1;
            document.getElementById('startPairValue').textContent = '1';
            
            document.getElementById('endPair').value = 41;
            document.getElementById('endPairValue').textContent = '41';
            
            // Reset cloudiness checkboxes to include both by default
            document.getElementById('includePartlyCloudy').checked = true;
            document.getElementById('includeMostlyCloudy').checked = true;
            
            // Reset threshold sliders to defaults
            document.getElementById('clearBrightnessMin').value = 120;
            document.getElementById('clearBrightnessMinValue').textContent = '120';
            
            document.getElementById('clearContrastMin').value = 50;
            document.getElementById('clearContrastMinValue').textContent = '50';
            
            document.getElementById('cloudyBrightnessMax').value = 60;
            document.getElementById('cloudyBrightnessMaxValue').textContent = '60';
            
            document.getElementById('cloudyContrastMax').value = 15;
            document.getElementById('cloudyContrastMaxValue').textContent = '15';
            
            // Reset user modification flag
            userModifiedEndPair = false;
            
            // Update button text if data is loaded
            if (plotData) {
                updateLoadButton('Refresh Data');
            }
        }
        
        async function clearCache() {
            const folder = document.getElementById('folderSelect').value;
            if (!folder) {
                showStatus('Please select a folder first', 'error');
                return;
            }
            
            if (!confirm('Are you sure you want to clear the cache for this folder? This will force re-processing of all images next time.')) {
                return;
            }
            
            try {
                showStatus('Clearing cache...', 'info');
                const response = await fetch(`/api/clear-cache/${encodeURIComponent(folder)}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    showStatus('Cache cleared successfully', 'success');
                } else {
                    showStatus('Failed to clear cache', 'error');
                }
            } catch (error) {
                showStatus('Error clearing cache: ' + error.message, 'error');
            }
        }
        
        async function loadFolders() {
            try {
                const response = await fetch('/api/folders');
                const folders = await response.json();
                
                const select = document.getElementById('folderSelect');
                select.innerHTML = '<option value="">Select a folder...</option>';
                
                folders.forEach(folder => {
                    const option = document.createElement('option');
                    option.value = folder.name;
                    option.textContent = `${folder.name} (${folder.count} images)`;
                    select.appendChild(option);
                });
                
                
            } catch (error) {
                showStatus('Error loading folders: ' + error.message, 'error');
            }
        }
        
        
        async function loadData() {
            const folder = document.getElementById('folderSelect').value;
            if (!folder) {
                showStatus('Please select a folder', 'error');
                return;
            }
            
            const isRefresh = plotData !== null;
            
            if (!isRefresh) {
                // Clear existing data and reset UI for initial load
                await clearExistingData();
            }
            
            const params = {
                folder: folder,
                // Only include enabled filters
                enable_percentile: document.getElementById('enablePercentile').checked,
                pair_percentile: parseFloat(document.getElementById('pairPercentile').value),
                filter_order: window.currentFilterOrder || ['sequence', 'keypoint_percentile', 'percentile', 'std_dev', 'cloudiness', 'gps_consistency'],
                enable_std_dev: document.getElementById('enableStdDev').checked,
                std_dev_multiplier: parseFloat(document.getElementById('stdDevMultiplier').value),
                enable_keypoint_percentile: document.getElementById('enableKeypointPercentile').checked,
                keypoint_percentile: parseFloat(document.getElementById('keypointPercentile').value),
                enable_sequence: document.getElementById('enableSequence').checked,
                start_pair: parseInt(document.getElementById('startPair').value),
                end_pair: parseInt(document.getElementById('endPair').value),
                enable_cloudiness: document.getElementById('enableCloudiness').checked,
                include_partly_cloudy: document.getElementById('includePartlyCloudy').checked,
                include_mostly_cloudy: document.getElementById('includeMostlyCloudy').checked,
                clear_brightness_min: parseFloat(document.getElementById('clearBrightnessMin').value),
                clear_contrast_min: parseFloat(document.getElementById('clearContrastMin').value),
                cloudy_brightness_max: parseFloat(document.getElementById('cloudyBrightnessMax').value),
                cloudy_contrast_max: parseFloat(document.getElementById('cloudyContrastMax').value),
                enable_gps_consistency: document.getElementById('enableGpsConsistency').checked,
                gps_tolerance_constant: parseFloat(document.getElementById('gpsToleranceConstant').value),
                speed_mode: document.getElementById('speedMode').value
            };
            
            const actionText = isRefresh ? 'Refreshing data with new parameters...' : 'Starting data processing...';
            showStatus(actionText, 'info');
            showProgress(true);
            updateProgress(0, 'Initializing...');
            document.getElementById('loadBtn').disabled = true;
            
            // Reset polling counter for new load
            pollingAttempts = 0;
            
            try {
                const response = await fetch('/api/process', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });
                
                if (response.ok) {
                    // Poll for completion with progress updates
                    pollStatusWithProgress();
                } else {
                    throw new Error('Failed to start processing');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
                showProgress(false);
                document.getElementById('loadBtn').disabled = false;
            }
        }
        
        async function pollStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();
                
                if (status.processed) {
                    showStatus(`Data loaded: ${status.keypoint_count} keypoints from ${status.pair_count} pairs`, 'success');
                    document.getElementById('loadBtn').disabled = false;
                    await refreshData();
                } else {
                    setTimeout(pollStatus, 1000);
                }
            } catch (error) {
                showStatus('Error checking status: ' + error.message, 'error');
                document.getElementById('loadBtn').disabled = false;
            }
        }
        
        let pollingAttempts = 0;
        const maxPollingAttempts = 120; // 60 seconds max (120 * 500ms)
        
        async function pollStatusWithProgress() {
            try {
                pollingAttempts++;
                
                if (pollingAttempts > maxPollingAttempts) {
                    showStatus('Processing timeout - please try again', 'error');
                    showProgress(false);
                    document.getElementById('loadBtn').disabled = false;
                    return;
                }
                
                const response = await fetch('/api/status');
                const status = await response.json();
                
                if (status.processed) {
                    updateProgress(100, 'Complete!');
                    showStatus(`Data loaded: ${status.keypoint_count} keypoints from ${status.pair_count} pairs`, 'success');
                    showProgress(false);
                    document.getElementById('loadBtn').disabled = false;
                    updateLoadButton('Refresh Data');
                    
                    // Update sequence range limits based on actual pair count
                    setTimeout(() => {
                        updateSequenceRangeLimits(status.pair_count);
                    }, 100);
                    
                    // Load the plot data without triggering another processing cycle
                    await refreshData();
                } else {
                    // Update progress based on current status
                    const progress = status.progress || 0;
                    const details = status.details || 'Processing...';
                    updateProgress(progress, details);
                    setTimeout(pollStatusWithProgress, 500);
                }
            } catch (error) {
                showStatus('Error checking status: ' + error.message, 'error');
                showProgress(false);
                document.getElementById('loadBtn').disabled = false;
            }
        }
        
        async function refreshData() {
            try {
                console.log('Refreshing data with current parameters...');
                console.log('GPS Consistency enabled:', document.getElementById('enableGpsConsistency').checked);
                console.log('GPS Tolerance constant:', document.getElementById('gpsToleranceConstant').value);
                console.log('Current filter order:', window.currentFilterOrder);
                console.log('Default filter order:', ['sequence', 'keypoint_percentile', 'percentile', 'std_dev', 'cloudiness', 'gps_consistency']);
                
                // Get current filter parameters
                const params = new URLSearchParams({
                    enable_percentile: document.getElementById('enablePercentile').checked,
                    pair_percentile: document.getElementById('pairPercentile').value,
                    filter_order: JSON.stringify(window.currentFilterOrder || ['sequence', 'keypoint_percentile', 'percentile', 'std_dev', 'cloudiness', 'gps_consistency']),
                    enable_std_dev: document.getElementById('enableStdDev').checked,
                    std_dev_multiplier: document.getElementById('stdDevMultiplier').value,
                    enable_keypoint_percentile: document.getElementById('enableKeypointPercentile').checked,
                    keypoint_percentile: document.getElementById('keypointPercentile').value,
                    enable_sequence: document.getElementById('enableSequence').checked,
                    start_pair: document.getElementById('startPair').value,
                    end_pair: document.getElementById('endPair').value,
                    enable_cloudiness: document.getElementById('enableCloudiness').checked,
                    include_partly_cloudy: document.getElementById('includePartlyCloudy').checked,
                    include_mostly_cloudy: document.getElementById('includeMostlyCloudy').checked,
                    clear_brightness_min: document.getElementById('clearBrightnessMin').value,
                    clear_contrast_min: document.getElementById('clearContrastMin').value,
                    cloudy_brightness_max: document.getElementById('cloudyBrightnessMax').value,
                    cloudy_contrast_max: document.getElementById('cloudyContrastMax').value,
                    enable_gps_consistency: document.getElementById('enableGpsConsistency').checked,
                    gps_tolerance_constant: document.getElementById('gpsToleranceConstant').value,
                    speed_mode: document.getElementById('speedMode').value
                });
                
                console.log('Sending parameters:', params.toString());
                const response = await fetch(`/api/plot-data?${params}`);
                plotData = await response.json();
                
                console.log('Plot data loaded:', plotData);
                console.log('Histogram speeds count:', plotData.histogram?.speeds?.length);
                console.log('Pairs count:', plotData.pairs?.pairs?.length);
                
                if (plotData.error) {
                    showStatus(plotData.error, 'error');
                    return;
                }
                
                // Update GPS status if available
                if (plotData.gps_enabled !== undefined) {
                    updateGpsStatus(plotData.gps_enabled);
                }
                
                // Store individual keypoint data for filtering
                window.allKeypointsData = plotData.keypoints || [];
                
                // Update GPS consistency filter availability
                updateGpsConsistencyAvailability(plotData.gps_enabled || false);
                
                createPlots();
            } catch (error) {
                showStatus('Error loading plot data: ' + error.message, 'error');
            }
        }
        
        
        function updateSpeedometer() {
            console.log('updateSpeedometer called, plotData:', plotData);
            if (!plotData) {
                console.log('No plotData available');
                return;
            }
            
            const speedMode = document.getElementById('speedMode').value;
            console.log('Speed mode:', speedMode);
            console.log('plotData.speedometers:', plotData.speedometers);
            let speed, mode, count;
            
            if (plotData.speedometers) {
                switch(speedMode) {
                    case 'gps_only':
                        speed = plotData.speedometers.gps_only?.speed || 0;
                        mode = 'GPS-Only';
                        count = plotData.speedometers.gps_only?.count || 0;
                        break;
                    case 'constant_gsd':
                        speed = plotData.speedometers.constant_gsd?.speed || 0;
                        mode = 'Constant GSD (ESA)';
                        count = plotData.speedometers.constant_gsd?.count || 0;
                        break;
                    case 'dynamic_gsd':
                        speed = plotData.speedometers.dynamic_gsd?.speed || 0;
                        mode = 'Dynamic GSD (GPS+Keypoints)';
                        count = plotData.speedometers.dynamic_gsd?.count || 0;
                        break;
                    default:
                        speed = plotData.histogram?.mean || 0;
                        mode = 'Overall Average';
                        count = plotData.histogram?.speeds?.length || 0;
                }
            } else {
                speed = plotData.histogram?.mean || 0;
                mode = 'Overall Average';
                count = plotData.histogram?.speeds?.length || 0;
            }
            
            document.getElementById('currentSpeed').textContent = speed.toFixed(3);
            document.getElementById('currentMode').textContent = `${mode} (${count} points)`;
            console.log(`Speedometer updated: ${speed.toFixed(3)} km/s, ${mode} (${count} points)`);
        }
        
        function showEmptyPlots() {
            // Show empty state for all plots
            const emptyMessage = {
                x: [0.5],
                y: [0.5],
                mode: 'text',
                text: ['No data available<br>Try adjusting parameters'],
                textfont: {size: 16, color: '#666'},
                showlegend: false,
                hoverinfo: 'skip'
            };
            
            const emptyLayout = {
                xaxis: {visible: false},
                yaxis: {visible: false},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                margin: {l: 0, r: 0, t: 0, b: 0}
            };
            
            // Clear plots with empty state
            Plotly.newPlot('histogram', [emptyMessage], emptyLayout);
            Plotly.newPlot('pairs', [emptyMessage], emptyLayout);
            
            // Reset speedometer
            const currentSpeedElement = document.getElementById('currentSpeed');
            const currentModeElement = document.getElementById('currentMode');
            if (currentSpeedElement) currentSpeedElement.textContent = '--';
            if (currentModeElement) currentModeElement.textContent = '--';
        }
        
        function createPlots() {
            console.log('createPlots called, plotData:', plotData);
            if (!plotData) {
                console.log('No plotData available in createPlots');
                return;
            }
            
            // Update speedometer
            updateSpeedometer();
            
            // Check if we have data
            const hasData = plotData.histogram.speeds.length > 0;
            
            if (!hasData) {
                // Show empty state for all plots
                showEmptyPlots();
                return;
            }
            
            // Histogram
            const speeds = plotData.histogram.speeds;
            const minSpeed = Math.min(...speeds);
            const maxSpeed = Math.max(...speeds);
            const speedRange = maxSpeed - minSpeed;
            const binSize = Math.max(0.1, speedRange / 30); // At least 0.1 km/s bins, max 30 bins
            
            Plotly.newPlot('histogram', [{
                x: speeds,
                type: 'histogram',
                xbins: {
                    start: minSpeed - binSize/2,
                    end: maxSpeed + binSize/2,
                    size: binSize
                },
                marker: {color: 'skyblue', line: {color: 'black', width: 1}},
                name: 'Speed Distribution'
            }], {
                title: 'Speed Distribution of All Keypoints',
                xaxis: {
                    title: 'Speed (km/s)',
                    range: [minSpeed - speedRange * 0.05, maxSpeed + speedRange * 0.05]
                },
                yaxis: {title: 'Number of Keypoints'},
                shapes: [
                    {type: 'line', x0: plotData.histogram.mean, x1: plotData.histogram.mean, y0: 0, y1: 1, yref: 'paper', line: {color: 'red', width: 2, dash: 'dash'}},
                    {type: 'line', x0: 7.66, x1: 7.66, y0: 0, y1: 1, yref: 'paper', line: {color: 'orange', width: 3}}
                ],
                annotations: [
                    {x: plotData.histogram.mean, y: 0.9, yref: 'paper', text: `Mean: ${plotData.histogram.mean.toFixed(3)} km/s`, showarrow: false, xanchor: 'left'},
                    {x: 7.66, y: 0.8, yref: 'paper', text: 'Target: 7.66 km/s', showarrow: false, xanchor: 'left'}
                ]
            });
            
            // Pairs plot (interactive) - Group by color to avoid legend repetition
            const colorGroups = {
                'green': {x: [], y: [], error_y: [], customdata: []},
                'orange': {x: [], y: [], error_y: [], customdata: []},
                'red': {x: [], y: [], error_y: [], customdata: []}
            };
            
            // Group data by color (only if we have pairs data)
            if (plotData.pairs.pairs && plotData.pairs.pairs.length > 0) {
                for (let i = 0; i < plotData.pairs.pairs.length; i++) {
                    const color = plotData.pairs.colors[i];
                    if (colorGroups[color]) {
                        colorGroups[color].x.push(plotData.pairs.pairs[i]);
                        colorGroups[color].y.push(plotData.pairs.means[i]);
                        colorGroups[color].error_y.push(plotData.pairs.stds[i]);
                        colorGroups[color].customdata.push(plotData.pairs.original_pairs[i]);
                    }
                }
            }
            
            // Create traces for each color group
            const pairTraces = [];
            const colorMap = {green: 'Clear', orange: 'Partly Cloudy', red: 'Mostly Cloudy'};
            
            Object.keys(colorGroups).forEach(color => {
                const group = colorGroups[color];
                if (group.x.length > 0) {
                    pairTraces.push({
                        x: group.x,
                        y: group.y,
                        error_y: {type: 'data', array: group.error_y},
                        mode: 'markers',
                        marker: {color: color, size: 10},
                        name: colorMap[color],
                        customdata: group.customdata,
                        hovertemplate: 'Pair: %{customdata}<br>Speed: %{y:.3f} km/s<br>Std: %{error_y.array[0]:.3f}<br>Click to view images<extra></extra>'
                    });
                }
            });
            
            Plotly.newPlot('pairs', pairTraces, {
                title: 'Average Speed per Image Pair',
                xaxis: {title: 'Image Pair Number'},
                yaxis: {title: 'Average Speed (km/s)'},
                shapes: [
                    {type: 'line', x0: 0, x1: 1, xref: 'paper', y0: 7.66, y1: 7.66, line: {color: 'blue', width: 3}}
                ],
                annotations: [
                    {x: 0.5, y: 7.66, xref: 'paper', text: 'Target: 7.66 km/s', showarrow: false, yanchor: 'bottom'}
                ]
            });
            
            // Add click event to pairs plot
            document.getElementById('pairs').on('plotly_click', function(data) {
                console.log('Plot click event:', data);
                const pairNum = data.points[0].customdata;
                console.log('Clicked pair number:', pairNum);
                showPairImages(pairNum);
            });
            
            // Add legend click functionality for filtering
            document.getElementById('pairs').on('plotly_legendclick', function(data) {
                const legendItem = data.curveNumber;
                const traceName = data.fullData[legendItem].name;
                
                // Toggle visibility of the clicked legend item
                const update = {
                    visible: data.fullData[legendItem].visible === 'legendonly' ? true : 'legendonly'
                };
                
                Plotly.restyle('pairs', update, [legendItem]);
                
                // Recalculate and update other graphs based on visible data
                updateFilteredGraphs();
            });
        }
        
        async function showPairImages(pairNum) {
            console.log('showPairImages called with pairNum:', pairNum);
            try {
                const response = await fetch(`/api/pair/${pairNum}`);
                console.log('API response status:', response.status);
                const data = await response.json();
                console.log('API response data:', data);
                
                if (data.error) {
                    showStatus(data.error, 'error');
                    return;
                }
                
                document.getElementById('modalTitle').textContent = `Pair ${pairNum} Details`;
                
                const content = `
                    <div class="pair-info">
                        <h3>Pair Information</h3>
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">Average Speed (Dynamic GSD):</span>
                                <span class="info-value">${data.avg_speed.toFixed(3)} km/s</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Standard Deviation:</span>
                                <span class="info-value">${data.std_speed.toFixed(3)} km/s</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Keypoints:</span>
                                <span class="info-value">${data.keypoint_count}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Time Difference:</span>
                                <span class="info-value">${data.time_diff} seconds</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Image Quality:</span>
                                <span class="info-value">${data.cloudiness}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Brightness:</span>
                                <span class="info-value">${data.brightness.toFixed(1)}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Contrast:</span>
                                <span class="info-value">${data.contrast.toFixed(1)}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Accuracy:</span>
                                <span class="info-value">${data.accuracy.toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="speed-methods">
                        <h3>Speed Calculation Methods</h3>
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">GPS-Only Speed:</span>
                                <span class="info-value">${data.gps_only_avg ? data.gps_only_avg.toFixed(3) : 'N/A'} km/s (${data.gps_only_count} points)</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Constant GSD Speed:</span>
                                <span class="info-value">${data.constant_gsd_avg ? data.constant_gsd_avg.toFixed(3) : 'N/A'} km/s (${data.constant_gsd_count} points)</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Dynamic GSD Speed:</span>
                                <span class="info-value">${data.dynamic_gsd_avg ? data.dynamic_gsd_avg.toFixed(3) : 'N/A'} km/s (${data.dynamic_gsd_count} points)</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="gps-metadata">
                        <h3>GPS Metadata</h3>
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">Image 1 GPS:</span>
                                <span class="info-value">${data.gps1 ? `${data.gps1[0].toFixed(6)}°N, ${data.gps1[1].toFixed(6)}°E` : 'Not available'}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Image 2 GPS:</span>
                                <span class="info-value">${data.gps2 ? `${data.gps2[0].toFixed(6)}°N, ${data.gps2[1].toFixed(6)}°E` : 'Not available'}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">GPS Distance:</span>
                                <span class="info-value">${data.gps_distance_km ? data.gps_distance_km.toFixed(3) + ' km' : 'Not available'}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="image-container">
                        <div class="image-box">
                            <h4>${data.image1}</h4>
                            <img src="data:image/jpeg;base64,${data.image1_data}" alt="Image 1">
                        </div>
                        <div class="image-box">
                            <h4>${data.image2}</h4>
                            <img src="data:image/jpeg;base64,${data.image2_data}" alt="Image 2">
                        </div>
                    </div>
                    
                    <div class="keypoint-matches">
                        <h3>Keypoint Matches (${data.displayed_matches} of ${data.total_matches} shown)</h3>
                        <p>Lines connect matching keypoints between the two images. This shows how features moved between the images.</p>
                        <img src="data:image/jpeg;base64,${data.matches_data}" alt="Keypoint Matches" style="max-width: 100%; height: auto; border: 1px solid #dee2e6; border-radius: 4px;">
                    </div>
                `;
                
                document.getElementById('modalContent').innerHTML = content;
                document.getElementById('imageModal').style.display = 'block';
                console.log('Modal displayed for pair:', pairNum);
                
            } catch (error) {
                showStatus('Error loading pair images: ' + error.message, 'error');
            }
        }
        
        function closeModal() {
            document.getElementById('imageModal').style.display = 'none';
        }
        
        function updateFilteredGraphs() {
            if (!plotData || !window.allKeypointsData) return;
            
            // Get the current state of the pairs plot
            const pairsDiv = document.getElementById('pairs');
            const pairsData = pairsDiv.data;
            
            // Collect all visible pair numbers
            const visiblePairs = new Set();
            
            // Get all pair numbers that are currently visible
            for (let i = 0; i < pairsData.length; i++) {
                const trace = pairsData[i];
                if (trace.visible !== 'legendonly' && trace.visible !== false) {
                    // This trace is visible, add its data
                    for (let j = 0; j < trace.x.length; j++) {
                        const pairNum = trace.x[j];
                        visiblePairs.add(pairNum);
                    }
                }
            }
            
            // Filter keypoints based on visible pairs
            const filteredKeypoints = window.allKeypointsData.filter(kp => visiblePairs.has(kp.pair_num));
            const filteredSpeeds = filteredKeypoints.map(kp => kp.speed);
            
            if (filteredSpeeds.length === 0) {
                showEmptyPlots();
                return;
            }
            
            // Update histogram with filtered data
            const meanSpeed = filteredSpeeds.reduce((a, b) => a + b, 0) / filteredSpeeds.length;
            const sortedSpeeds = [...filteredSpeeds].sort((a, b) => a - b);
            const medianSpeed = sortedSpeeds[Math.floor(sortedSpeeds.length / 2)];
            const stdSpeed = Math.sqrt(filteredSpeeds.reduce((sq, n) => sq + Math.pow(n - meanSpeed, 2), 0) / filteredSpeeds.length);
            
            Plotly.newPlot('histogram', [{
                x: filteredSpeeds,
                type: 'histogram',
                nbinsx: 50,
                marker: {color: 'skyblue', line: {color: 'black', width: 1}},
                name: 'Speed Distribution'
            }], {
                title: `Speed Distribution (${filteredSpeeds.length} keypoints)`,
                xaxis: {title: 'Speed (km/s)'},
                yaxis: {title: 'Number of Keypoints'},
                shapes: [
                    {type: 'line', x0: meanSpeed, x1: meanSpeed, y0: 0, y1: 1, yref: 'paper', line: {color: 'red', width: 2, dash: 'dash'}},
                    {type: 'line', x0: 7.66, x1: 7.66, y0: 0, y1: 1, yref: 'paper', line: {color: 'orange', width: 3}}
                ],
                annotations: [
                    {x: meanSpeed, y: 0.9, yref: 'paper', text: `Mean: ${meanSpeed.toFixed(3)} km/s`, showarrow: false, xanchor: 'left'},
                    {x: 7.66, y: 0.8, yref: 'paper', text: 'Target: 7.66 km/s', showarrow: false, xanchor: 'left'}
                ]
            });
            
            // Update speedometer - this will be handled by updateSpeedometer() function
            // which gets called after plot data is loaded
            
            // Show status
            showStatus(`Filtered to ${filteredSpeeds.length} keypoints from ${visiblePairs.size} pairs. Mean speed: ${meanSpeed.toFixed(3)} km/s`, 'info');
        }
        
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 5000);
            }
        }
        
        function updateGpsStatus(gpsEnabled) {
            const gpsStatus = document.getElementById('gpsStatus');
            const gpsText = document.getElementById('gpsText');
            
            if (gpsEnabled) {
                gpsText.textContent = 'GPS Enhanced Mode - Dynamic GSD Calculation';
                gpsStatus.style.display = 'flex';
            } else {
                gpsStatus.style.display = 'none';
            }
        }
        
        function showProgress(show = true) {
            const progressContainer = document.getElementById('progressContainer');
            progressContainer.style.display = show ? 'block' : 'none';
        }
        
        function updateProgress(percent, details = '') {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressDetails = document.getElementById('progressDetails');
            
            progressBar.style.width = percent + '%';
            progressText.textContent = Math.round(percent) + '%';
            progressDetails.textContent = details;
        }
        
        async function clearExistingData() {
            try {
                // Clear backend data
                await fetch('/api/clear', { method: 'POST' });
                
                // Clear frontend data
                plotData = null;
                
                // Reset speedometer
                const currentSpeedElement = document.getElementById('currentSpeed');
                const currentModeElement = document.getElementById('currentMode');
                if (currentSpeedElement) currentSpeedElement.textContent = '--';
                if (currentModeElement) currentModeElement.textContent = '--';
                
                // Clear plots
                const plotIds = ['histogram', 'pairs'];
                plotIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.innerHTML = '';
                    }
                });
                
                // Hide progress bar
                showProgress(false);
                
                showStatus('Previous data cleared', 'info');
                
            } catch (error) {
                console.log('Error clearing data:', error);
                // Continue anyway - this is not critical
            }
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('imageModal');
            if (event.target === modal) {
                closeModal();
            }
        }
    </script>
</body>
</html>